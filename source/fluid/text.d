module fluid.text;

import std.uni;
import std.math;
import std.range;
import std.traits;
import std.string;
import std.algorithm;

import fluid.node;
import fluid.style;
import fluid.utils;
import fluid.backend;
import fluid.typeface;

public import fluid.rope;


@safe:


/// Create a Text struct with given range as a text layer map.
StyledText!StyleRange mapText(StyleRange)(Node node, const char[] text, StyleRange range) {

    return typeof(return)(node, text, range);

}

alias Text = StyledText!();

/// Draws text: handles updates, formatting and styling.
struct StyledText(StyleRange = TextStyleSlice[]) {

    static assert(isForwardRange!StyleRange,
        "StyleRange must be a valid forward range of TextStyleSlices");
    static assert(is(ElementType!StyleRange : TextStyleSlice),
        "StyleRange must be a valid forward range of TextStyleSlices");

    /// Minimum distance between automatically created checkpoints.
    /// See_Also: `_cache`, `measure`
    private enum checkpointDistance = 128;
    static assert(checkpointDistance > CachedTextRuler.sizeof);

    public {

        /// Node owning this text struct.
        Node node;

        /// Texture generated by the struct.
        CompositeTexture texture;

        /// Range assigning slices of text to styles by index. A single text can have up to 256 different styles.
        ///
        /// Ranges should not overlap, and must be ordered by `start`. If a piece of text is not matched, it is assumed
        /// to belong to style 0.
        StyleRange styleMap;

        /// If true, enables optimizations for frequently edited text.
        bool hasFastEdits;

        /// Indent width, in pixels.
        float indentWidth = 32;

    }

    private {

        /// Last used DPI.
        Vector2 _dpi;

        /// Last used font size.
        float _fontSize;

        /// Cache of all measured text segments.
        TextRulerCache _cache;

        /// Underlying text.
        Rope _value;

        /// Text bounding box size, in dots.
        Vector2 _sizeDots;

        /// If true, text will be wrapped if it doesn't fit available space.
        bool _wrap;

        /// Start and end of the update range; area of the text that was updated since the last resize and has to be
        /// measured again. Both are inclusive.
        size_t _updateRangeStart, _updateRangeEnd;

    }

    alias minSize = size;
    alias value this;

    static if (is(StyleRange == TextStyleSlice[]))
    this(Node node, Rope text) {

        this.node = node;
        opAssign(text);

    }

    this(Node node, Rope text, StyleRange styleMap) {

        this.styleMap = styleMap;
        this.node = node;
        opAssign(text);

    }

    static if (is(StyleRange == TextStyleSlice[]))
    this(Node node, const(char)[] text) {

        this.node = node;
        opAssign(text);

    }

    this(Node node, const(char)[] text, StyleRange styleMap) {

        this.styleMap = styleMap;
        this.node = node;
        opAssign(text);

    }

    /// Copy the text, clear ownership and texture.
    this(StyledText text) const {

        this.node = null;
        this._value = text.value;
        this.styleMap = text.styleMap.save;

    }

    inout(FluidBackend) backend() inout {

        if (node.tree)
            return node.tree.backend;
        else
            return null;

    }

    /// Get or the value rendered by this text.
    /// 
    /// If more text is rendered, partial changes should be done through `replace`.
    ///
    /// Params:
    ///     newValue = Set a new value for this text.
    /// Returns: The value.
    ref inout(Rope) value() inout {

        return _value;

    }

    /// ditto
    Rope value(Rope newValue) {

        replace(0, _value.length, newValue);
        return _value;

    }

    /// ditto
    Rope value(const char[] newValue) {

        return value(Rope(newValue));

    }

    /// Clear cache and reload all text.
    void reload() {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        auto width = _cache.startRuler.lineWidth;

        clearCache(typeface, width);

    }

    /// Queue reloading text in range. If the range changes length, specify both oldHigh and newHigh.
    ///
    /// This does NOT perform the action immediately. It updates text intervals in the cache, and marks the 
    /// area that needs to be remeasurement. Positions will update on the next resize, which is triggered as this 
    /// function is called.
    ///
    /// Params:
    ///     start       = Interval from text to start of both ranges, inclusive.
    ///     oldInterval = Interval covering the now deleted text.
    ///     newInterval = Interval covering the newly inserted text. If omitted, it is assumed to be the same and
    ///         the interval size does not change.
    void reload(TextInterval start, TextInterval oldInterval, TextInterval newInterval) {

        const newEnd = start + newInterval;

        node.updateSize();

        // Make sure each of the previously added TextRuler cache checkpoints point to the same characters, still.
        // It is likely some of their positions have stayed the same, at least partially, which can save us a lot of
        // time if we reuse them.
        _cache.updateInterval(start, oldInterval, newInterval);

        // No update range is set, replace it
        if (_updateRangeStart == _updateRangeEnd) {

            _updateRangeStart = start.length;
            _updateRangeEnd   = newEnd.length;
    
        }

        // Update boundaries of the existing update range
        else {

            if (start.length < _updateRangeStart)
                _updateRangeStart = start.length;

            if (newEnd.length > _updateRangeEnd)
                _updateRangeEnd = newEnd.length;

        }
        
    }

    /// Replace value at a given range with a new value. This is the main, and fastest way to operate on TextInput text.
    ///
    /// Params:
    ///     start  = Start index, inclusive; First index to delete.
    ///     end    = End index, exclusive; First index after the newly inserted fragment.
    ///     value  = Value to insert.
    void replace(size_t start, size_t end, Rope value) {

        // Ignore if there's no change
        if (start == end && value.length == 0) return;

        const startInterval = positionOf(start);
        const oldInterval   = positionOf(end)
            .dropHead(startInterval);

        _value = _value.replace(start, end, value);

        const newInterval = TextInterval(value);
        
        reload(startInterval, oldInterval, newInterval);

    }

    /// ditto
    void replace(size_t start, size_t end, const(char)[] value) {

        replace(start, end, Rope(value));

    }

    /// Returns: 
    ///     Interval between the start of text and the character at given index. This can be used to determine the line
    ///     and column number of the given character.
    /// Params:
    ///     index = Index to search for.
    TextInterval positionOf(size_t index) {

        // Find a suitable point to start search at
        const range = query(&_cache, index);
        const point = range.front.point;

        const start = point.length;
        const end   = index;

        return point + TextInterval(value[start .. end]);

    }

    Rope opAssign(Rope text) {

        // Identical; no change is to be made
        if (text is value) return text;

        // Request an update
        node.updateSize();
        return value = text;


    }

    const(char)[] opAssign(const(char)[] text) {

        // Ignore if there's no change to be made
        if (text == value) return text;

        // Request update otherwise
        value = text;
        return text;

    }

    string opIndexAssign(string value, size_t[2] index) {

        replace(index[0], index[1], Rope(value));
        return value;

    }

    Rope opIndexAssign(Rope value, size_t[2] index) {

        replace(index[0], index[1], value);
        return value;

    }

    char opIndex(size_t index) const nothrow {

        return value[index];

    }

    Rope opIndex(size_t[2] index) const nothrow {

        return value[index];
        
    }

    size_t[2] opSlice(size_t dim : 0)(size_t i, size_t j) const nothrow {

        return [i, j];

    }

    size_t opDollar() const nothrow {

        return value.length;

    }
    
    void opOpAssign(string operator : "~")(const(char)[] text) {

        replace(value.length, value.length, text);

    }

    void opOpAssign(string operator : "~")(Rope text) {

        replace(value.length, value.length, text);

    }

    /// Get the size of the text.
    Vector2 size() const {

        const scale = backend.hidpiScale;

        return Vector2(
            _sizeDots.x / scale.x,
            _sizeDots.y / scale.y,
        );

    }

    alias minSize = size;

    /// Measure and set the bounding box for this text.
    void resize() {

        resize!keepWords(Vector2(), false);

    }

    /// Set new bounding box for the text; wrap the text if it doesn't fit in boundaries.
    /// Params:
    ///     splitter = Function to use to split the text. Currently unsupported.
    ///     space    = Boundaries to fit the text in.
    ///     wrap     = Wrap text, on by default.
    void resize(alias splitter = Typeface.defaultWordChunks)(Vector2 space, bool wrap = true)
    in (node, "Text was not initialized; `node` was not set.")
    do {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const dpi = backend.dpi;
        const scale = backend.hidpiScale;

        // Apply DPI
        style.setDPI(dpi);
        typeface.indentWidth = cast(int) (indentWidth * scale.x);
        space.x *= scale.x;
        space.y *= scale.y;

        /// Minimum pixel change that counts
        measure!splitter(space, wrap);
        clearTextures();

    }

    /// Returns: Number of pixels in both directions that may make a notable visual difference.
    private Vector2 epsilon() const {

        return 96 / 4 / backend.dpi;

    }

    /// Test for changes to text properties: typeface, DPI, font size, box width and wrapping. 
    /// Returns: True if the cache should be purged. 
    private bool shouldCacheReset(Vector2 space, bool wrap) {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;

        const dpi = backend.dpi;
        const firstRuler = _cache.startRuler;
        const widthChanged = wrap && abs(space.x - firstRuler.lineWidth) >= epsilon.x;

        return widthChanged
            || typeface !is firstRuler.typeface
            || abs(dpi.x - _dpi.x) >= epsilon.x
            || abs(dpi.y - _dpi.y) >= epsilon.y
            || abs(style.fontSize - _fontSize) >= epsilon.y 
            || wrap != _wrap;

    }

    /// Clear the cache.
    private void clearCache(Typeface typeface, float lineWidth)
    in (typeface)
    do {

        auto ruler = TextRuler(typeface, lineWidth);
        ruler.startLine();
        _cache = TextRulerCache(ruler);
        _dpi = backend 
            ? backend.dpi
            : Vector2();
        _updateRangeStart = 0;
        _updateRangeEnd = value.length;

    }

    /// Measure text size in the update region and update `_sizeDots` to the bounding box of this text. Size is 
    /// expressed in terms of screen dots.
    /// 
    /// The update region is a single continuous area in the `value` that has been written since the last `measure` 
    /// call. Any changed piece of text will be placed in the update region to be picked up and measured by this 
    /// function. Because this function cannot distinguish between modifications made in multiple different spots, 
    /// unmodified text between two edited spots of text will be included in the region as well. This function
    /// resets the update region once it is finished.
    ///
    /// While measuring text in the update region, "checkpoints" with measurement data are created and written to 
    /// `_cache`. This makes it possible to find the position of a character in the text afterwards without having to 
    /// remeasure the entire text. Furthermore, it's used to make subsequent measurements faster as area before the 
    /// update region can be skipped, and lines after can be just offset without measuring them again.
    /// 
    /// Params:
    ///     splitter = Function to use to split words.
    ///     space   = Limit for the space of the region the text shouldn't cross, in dots.
    ///     wrap    = If true, text should be limited by a bounding box.
    private void measure(alias splitter = Typeface.defaultWordChunks)(Vector2 space, bool wrap)
    out (; isMeasured)
    do {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const epsilon = this.epsilon;

        // Unset space if wrapping is disabled
        if (!wrap) space = Vector2(float.nan, float.nan);

        // Reset the cache if text properties changed
        if (shouldCacheReset(space, wrap)) {
            clearCache(typeface, space.x);
            _wrap = wrap;
        }

        // Nothing to update
        if (_updateRangeStart == _updateRangeEnd && value != "") return;

        // Find the first beacon to update
        scope rulers = query(&_cache, _updateRangeStart);
        auto ruler = rulers.front;
        bool started;
        float yOffset = 0;
        rulers.popFront;

        assert(!wrap || abs(ruler.lineWidth - space.x) < epsilon.x,
            format!"Line width mismatch: ruler(%s), space(%s)"(ruler.lineWidth, space.x));

        const start = ruler.point.length;
        size_t lastCheckpoint = start;

        // Split on lines
        foreach (index, line; Typeface.lineSplitterIndex(value[start .. $])) {

            if (started) {
                ruler.startLine();
                ruler.point.line++;
                ruler.point.column = 0;
            }
            else started = true;

            // Split on words
            foreach (word, penPosition; Typeface.eachWord!splitter(ruler, line, wrap)) {

                const startIndex = index;

                index += word.length;

                // Keep the ruler's location in sync
                ruler.point.length = start + index;
                ruler.point.column += word.length;

                // If we're in the update range (iterating through newly added text), we need to periodically write 
                // rulers to cache 
                if (startIndex <= _updateRangeEnd) {

                    // Delete any outdated checkpoint in the cache
                    // TODO This might not even be necessary — cache should have already purged these points
                    while (!rulers.empty && index >= rulers.front.point.length) {

                        rulers.removeFront();

                    }

                    // Regularly create a checkpoint in the cache
                    if (index >= lastCheckpoint + checkpointDistance) {

                        lastCheckpoint = index;
                        _cache.insert(ruler.point, ruler);

                    }

                }

                // We're measuring text that should already have checkpoints written to cache.
                // We just need to compare with existing checkpoints and update them if necessary.
                else if (!rulers.empty) {

                    // X position is different, override the ruler and continue measurements
                    if (abs(rulers.front.penPosition.x - ruler.penPosition.x) >= epsilon.x) {
                        rulers.front = ruler;
                        continue;
                    }

                    // Only Y position is different, stop here and save the offset 
                    else if (abs(rulers.front.penPosition.y - ruler.penPosition.y) >= epsilon.y) {
                        yOffset = ruler.penPosition.y - rulers.front.penPosition.y;
                        rulers.front = ruler;
                    }

                    break;

                }

            }

        }

        // The remaining lines have not changes, so we can just apply the same offset we did on the last line
        if (yOffset)
        for (; !rulers.empty; rulers.popFront) {
            ruler = rulers.front;
            ruler.penPosition.y += yOffset;
            rulers.front = rulers.front;
        }

        // Now that the cache is built, we can find out what the position of the last character is so we can get 
        // the bounding box
        ruler = requireRulerAt(value.length);
        _sizeDots = ruler.textSize;
        _updateRangeStart = 0;
        _updateRangeEnd = 0;

    }

    bool isMeasured() const {

        return _cache !is _cache.init
            && _updateRangeStart == _updateRangeEnd;

    }

    /// `rulerAt` gets measurement data for the given text position. This data can be used to map characters to their 
    /// screen position or find their size. 
    ///
    /// `requireRulerAt` will do the same, but it will also cache the result value for faster subsequent lookup. The
    /// regular `rulerAt` overload is recommended for most cases.
    ///
    /// For this function to work, measurement data must be available; make sure `resize` was called beforehand. This
    /// will be checked at runtime.
    ///
    /// Returns: 
    ///     Text ruler with text measurement data from the start of the text to the given character, not including 
    ///     queried character.
    /// Params:
    ///     index = Index of the requested character.
    CachedTextRuler rulerAt(size_t index, bool preferNextLine = false)
    in (_cache !is _cache.init, "Text was not measured. Call `resize()` first.")
    do {

        // TODO Custom text breaking

        /// Returns the longest unbreakable substring of the given value.
        Rope unbreakableChars(Rope value) {

            // Split on lines
            auto lines = Typeface.lineSplitter(value);
            if (lines.empty) return Rope.init;

            // Split on words
            auto chunks = Typeface.defaultWordChunks(lines.front);
            if (chunks.empty) return Rope.init;

            // Return empty string if the result starts with whitespace
            if (chunks.front.byDchar.front.isWhite) return value.init;

            // Return first word only
            return chunks.front;

        }

        alias splitter = Typeface.defaultWordChunks;

        auto ruler = query(&_cache, index).front;
        bool started;

        assert(ruler.typeface !is null);

        // Too much to calculate at once! Trigger a resize first
        if (index - ruler.point.length >= checkpointDistance) {

            // Y position does not matter at this moment
            resize(Vector2(ruler.lineWidth, 0), _wrap);

            // Query again
            ruler = query(&_cache, index).front;

        }

        // Check if the caret follows unbreakable characters
        // If the caret is surrounded by unbreakable characters, include them in the output to make sure the
        // word is wrapped correctly
        const unbreakablePrefix = unbreakableChars(
            value[0 .. index].wordBack(true)
        );
        const unbreakableSuffix = unbreakablePrefix.empty && !preferNextLine
            ? Rope.init
            : unbreakableChars(value[index .. $]);

        const start = ruler.point.length;
        const end   = index + unbreakableSuffix.length;

        // Split on lines
        foreach (line; Typeface.lineSplitter!(Yes.keepTerminator)(value[start .. end])) {

            if (started) {
                ruler.startLine();
                ruler.point.line++;
                ruler.point.column = 0;
            }
            else started = true;

            ruler.point.length += line.length;
            ruler.point.column += line.length;

            // Split on words, but don't do anything
            foreach (word, penPosition; Typeface.eachWord!splitter(ruler, line, _wrap)) { }

        }

        // If the position is mid-word, we have to remove the suffix
        // TODO textSize might be incorrect here
        ruler.penPosition.x -= ruler.typeface.measure(unbreakableSuffix[]).x;

        return ruler;

    }

    CachedTextRuler requireRulerAt(size_t index) {

        auto ruler = rulerAt(index);
        _cache.insert(ruler.point, ruler);
        return ruler;

    }

    /// Reset the texture, destroying it and replacing it with a blank.
    void clearTextures() {

        texture.format = Image.Format.palettedAlpha;
        texture.resize(_sizeDots, hasFastEdits);

    }

    /// Generate the textures, if not already generated.
    ///
    /// Params:
    ///     chunks = Indices of chunks that need to be regenerated.
    ///     position = Position of the text; If given, only on-screen chunks will be generated.
    void generate(Vector2 position) {

        generate(texture.visibleChunks(position, backend.windowSize));

    }

    /// ditto
    void generate(R)(R chunks) @trusted {

        // Empty, nothing to do
        if (chunks.empty) return;

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const dpi = backend.dpi;
        const scale = backend.hidpiScale;

        // Apply sizing settings
        style.setDPI(dpi);
        typeface.indentWidth = cast(int) (indentWidth * scale.x);

        // Ignore chunks which have already been generated
        auto newChunks = chunks
            .filter!(index => !texture.chunks[index].isValid);

        // No chunks to render, stop here
        if (newChunks.empty) return;

        // Clear the chunks
        foreach (chunkIndex; newChunks) {

            texture.clearImage(chunkIndex);

        }

        auto ruler = TextRuler(typeface, _sizeDots.x);

        // Copy the layer range, make it infinite
        auto styleMap = this.styleMap.save.chain(TextStyleSlice.init.repeat);

        // Run through the text
        foreach (index, line; Typeface.lineSplitterIndex(value)) {

            ruler.startLine();

            // Split on words
            // TODO use the splitter provided when resizing
            foreach (word, penPosition; Typeface.eachWord(ruler, line, _wrap)) {

                const wordEnd = index + word.length;

                // Split the word based on the layer map
                while (index != wordEnd) {

                    const remaining = wordEnd - index;
                    auto wordFragment = word[$ - remaining .. $];
                    auto range = styleMap.front;

                    // Advance the layer map if exceeded the end
                    if (index >= range.end) {
                        styleMap.popFront;
                        continue;
                    }

                    ubyte styleIndex;

                    // Match found here
                    if (index >= range.start) {

                        // Find the end of the range
                        const end = min(wordEnd, range.end) - index;
                        wordFragment = wordFragment[0 .. end];
                        styleIndex = range.styleIndex;

                    }

                    // Match found later
                    else if (range.start < wordEnd) {

                        wordFragment = wordFragment[0 .. range.start - index];

                    }

                    const currentPenPosition = penPosition;

                    // Draw the fragment to selected chunks
                    foreach (chunkIndex; newChunks) {

                        const chunkRect = texture.chunkRectangle(chunkIndex);

                        // Ignore chunks this word is not in the bounds of
                        const relevant = chunkRect.contains(ruler.caret(currentPenPosition).start)
                            || chunkRect.contains(ruler.caret.end);

                        if (!relevant) continue;

                        // Get pen position relative to this chunk
                        auto relativePenPosition = currentPenPosition - chunkRect.start;

                        // Note: relativePenPosition is passed by ref
                        auto image = texture.chunks[chunkIndex].image;
                        typeface.drawLine(image, relativePenPosition, wordFragment, styleIndex);

                        // Update the pen position; Result of this should be the same for each chunk
                        penPosition = relativePenPosition + chunkRect.start;

                    }

                    // Update the index
                    index += wordFragment.length;

                }

            }

        }

        // Load the updated chunks
        foreach (chunkIndex; newChunks) {

            texture.upload(backend, chunkIndex, dpi);

        }

    }

    /// Draw the text.
    void draw(const Style style, Vector2 position) {

        scope const Style[1] styles = [style];

        draw(styles, position);

    }

    /// ditto
    void draw(scope const Style[] styles, Vector2 position)
    in (styles.length >= 1, "At least one style must be passed to draw(Style[], Vector2)")
    do {

        import std.math;
        import fluid.utils;

        const rectangle = Rectangle(position.tupleof, size.tupleof);
        const screen = Rectangle(0, 0, node.io.windowSize.tupleof);

        // Ignore if offscreen
        if (!overlap(rectangle, screen)) return;

        // Regenerate visible textures
        generate(position);

        // Make space in the texture's palette
        if (texture.palette.length != styles.length)
            texture.palette.length = styles.length;

        // Fill it with text colors of each of the styles
        styles.map!"a.textColor".copy(texture.palette);

        // Draw the texture if present
        texture.drawAlign(backend, rectangle);

    }

    /// ditto
    deprecated("Use draw(Style, Vector2) instead. Hint: Use fluid.utils.start(Rectangle) to get the position vector.")
    void draw(const Style style, Rectangle rectangle) {

        // Should this "crop" the result?

        draw(style, Vector2(rectangle.x, rectangle.y));

    }

    string toString() const {

        import std.conv : to;

        return _value.to!string;

    }

}

struct TextStyleSlice {

    /// Start and end of this slice. Start is inclusive, end is exclusive. The range may exceed text boundaries.
    auto start = size_t.max;

    /// ditto
    auto end = size_t.max;

    invariant(start <= end);

    /// Index of the style to be assigned to the text covered by this slice.
    ubyte styleIndex;

    ptrdiff_t opCmp(const TextStyleSlice that) const {

        return cast(ptrdiff_t) this.start - cast(ptrdiff_t) that.start;

    }

    /// Apply some offset to the slice.
    TextStyleSlice offset(int offset) const {

        return TextStyleSlice(start + offset, end + offset, styleIndex);

    }

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();
    auto text = Text(root, "Hello, green world!");

    // Set colors for each part
    Style[4] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");
    styles[2].textColor = color("#55b9ff");
    styles[3].textColor = color("#0058f1");

    // Define regions
    text.styleMap = [
        TextStyleSlice(7, 12, 1),   // green
        TextStyleSlice(13, 14, 2),  // w
        TextStyleSlice(14, 15, 3),  // o
        TextStyleSlice(15, 16, 2),  // r
        TextStyleSlice(16, 17, 3),  // l
        TextStyleSlice(17, 18, 2),  // d
    ];

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize();
    text.draw(styles, Vector2(0, 0));

    // Make sure the texture was drawn with the correct color
    io.assertTexture(text.texture.chunks[0], Vector2(), color("#fff"));

    foreach (i; 0..4) {

        assert(text.texture.chunks[0].palette[i] == styles[i].textColor);
        assert(text.texture.palette[i] == styles[i].textColor);

    }

    // TODO Is there a way to reliably test if the result was drawn properly? Sampling specific pixels maybe?

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto styleMap = recurrence!"a[n-1] + 1"(0)
        .map!(a => TextStyleSlice(a, a+1, cast(ubyte) (a % 2)));

    auto text = mapText(root, "Hello, World!", styleMap);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(50, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto styleMap = [
        TextStyleSlice(2, 11, 1),
    ];

    auto text = mapText(root, "Hello, World!", styleMap);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(60, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    Style[2] styles;
    auto root = vspace();
    auto styleMap = [
        TextStyleSlice(0, 0, 1),
    ];
    auto text = mapText(root, "Hello, World!", styleMap);

    root.draw();
    text.resize();
    text.draw(styles, Vector2(0, 0));

}

/// A composite texture splits a larger area onto smaller chunks, making rendering large pieces of text more efficient.
struct CompositeTexture {

    enum maxChunkSize = 1024;

    struct Chunk {

        TextureGC texture;
        Image image;
        bool isValid;

        alias texture this;

    }

    /// Format of the texture.
    Image.Format format;

    /// Total size of the texture.
    Vector2 size;

    /// Underlying textures.
    ///
    /// Each texture, except for the last in each column or row, has the size of maxChunkSize on each side. The last
    /// texture in each row and column may have reduced width and height respectively.
    Chunk[] chunks;

    /// Palette to use for the texture, if relevant.
    Color[] palette;

    private bool _alwaysMax;

    this(Vector2 size, bool alwaysMax = false) {

        resize(size, alwaysMax);

    }

    /// Set a new size for the texture; recalculate the chunk number
    /// Params:
    ///     size      = New size of the texture.
    ///     alwaysMax = Always give chunks maximum size. Improves performance in nodes that frequently change their
    ///         content.
    void resize(Vector2 size, bool alwaysMax = false) {

        this.size = size;
        this._alwaysMax = alwaysMax;

        const chunkCount = columns * rows;

        this.chunks.length = chunkCount;

        // Invalidate the chunks
        foreach (ref chunk; chunks) {

            chunk.isValid = false;

        }

    }

    size_t chunkCount() const {

        return chunks.length;

    }

    size_t columns() const {

        return cast(size_t) ceil(size.x / maxChunkSize);

    }

    size_t rows() const {

        return cast(size_t) ceil(size.y / maxChunkSize);

    }

    size_t column(size_t i) const {

        return i % columns;

    }

    size_t row(size_t i) const {

        return i / columns;

    }

    /// Get the expected size of the chunk at given index
    Vector2 chunkSize(size_t i) const {

        // Return max chunk size if requested
        if (_alwaysMax)
            return Vector2(maxChunkSize, maxChunkSize);

        const x = column(i);
        const y = row(i);

        // Reduce size for last column
        const width = x + 1 == columns
            ? size.x % maxChunkSize
            : maxChunkSize;

        // Reduce size for last row
        const height = y + 1 == rows
            ? size.y % maxChunkSize
            : maxChunkSize;

        return Vector2(width, height);

    }

    /// Get index of the chunk at given X or Y.
    size_t index(size_t x, size_t y) const
    in (x < columns)
    in (y < rows)
    do {

        return x + y * columns;

    }

    /// Get position of the given chunk in dots.
    Vector2 chunkPosition(size_t i) const {

        const x = column(i);
        const y = row(i);

        return maxChunkSize * Vector2(x, y);

    }

    /// Get the rectangle of the given chunk in dots.
    /// Params:
    ///     i      = Index of the chunk.
    ///     offset = Translate the resulting rectangle by this vector.
    Rectangle chunkRectangle(size_t i, Vector2 offset = Vector2()) const {

        return Rectangle(
            (chunkPosition(i) + offset).tupleof,
            chunkSize(i).tupleof,
        );

    }

    /// Get a range of indices for all currently visible chunks.
    const visibleChunks(Vector2 position, Vector2 windowSize) {

        const offset = -position;
        const end = offset + windowSize;

        ptrdiff_t positionToIndex(alias round)(float position, ptrdiff_t limit) {

            const index = cast(ptrdiff_t) round(position / maxChunkSize);

            return index.clamp(0, limit);

        }

        const rowStart = positionToIndex!floor(offset.y, rows);
        const rowEnd = positionToIndex!ceil(end.y, rows);
        const columnStart = positionToIndex!floor(offset.x, columns);
        const columnEnd = positionToIndex!ceil(end.x, columns);

        // For each row
        return iota(rowStart, rowEnd)
            .map!(row =>

                // And each column
                iota(columnStart, columnEnd)

                    // Get its index
                    .map!(column => index(column, row)))
            .joiner;

    }

    /// Clear the image of the given chunk, making it transparent.
    void clearImage(size_t i) {

        const size = chunkSize(i);
        const width = cast(int) size.x;
        const height = cast(int) size.y;

        // Check if the size of the chunk has changed
        const sizeMatches = chunks[i].image.width == width
            && chunks[i].image.height == height;

        // Size matches, reuse the image
        if (sizeMatches)
            chunks[i].image.clear(PalettedColor.init);

        // No match, generate a new image
        else final switch (format) {

            case format.rgba:
                chunks[i].image = generateColorImage(width, height, color("#0000"));
                return;

            case format.palettedAlpha:
                chunks[i].image = generatePalettedImage(width, height, 0);
                return;

            case format.alpha:
                chunks[i].image = generateAlphaMask(width, height, 0);
                return;

        }

    }

    /// Update the texture of a given chunk using its corresponding image.
    void upload(FluidBackend backend, size_t i, Vector2 dpi) @trusted {

        const sizeMatches = chunks[i].image.width == chunks[i].texture.width
            && chunks[i].image.height == chunks[i].texture.height;

        // Size is the same as before, update the texture
        if (sizeMatches) {

            assert(chunks[i].texture.backend !is null);
            debug assert(backend is chunks[i].texture.backend,
                .format!"Backend mismatch %s != %s"(backend, chunks[i].texture.backend));

            chunks[i].texture.update(chunks[i].image);

        }

        // No match, create a new texture
        else {

            chunks[i].texture = TextureGC(backend, chunks[i].image);

        }

        // Update DPI
        chunks[i].texture.dpiX = cast(int) dpi.x;
        chunks[i].texture.dpiY = cast(int) dpi.y;

        // Mark as valid
        chunks[i].isValid = true;

    }

    /// Draw onscreen parts of the texture.
    void drawAlign(FluidBackend backend, Rectangle rectangle, Color tint = color("#fff")) {

        // Draw each visible chunk
        foreach (index; visibleChunks(rectangle.start, backend.windowSize)) {

            assert(chunks[index].texture.backend !is null);
            debug assert(backend is chunks[index].texture.backend,
                .format!"Backend mismatch %s != %s"(backend, chunks[index].texture.backend));

            const start = rectangle.start + chunkPosition(index);
            const size = chunks[index].texture.viewportSize;
            const rect = Rectangle(start.tupleof, size.tupleof);

            // Assign palette
            chunks[index].palette = palette;

            backend.drawTextureAlign(chunks[index], rect, tint);

        }

    }

}

@("Only visible chunks are redrawn")
unittest {

    import std.conv;
    import fluid.label;
    import fluid.scroll;

    enum chunkSize = CompositeTexture.maxChunkSize;

    auto io = new HeadlessBackend;
    auto root = vscrollable!label(
        nullTheme.derive(
            rule!Label(
                Rule.textColor = color("#000"),
            ),
        ),
        "One\nTwo\nThree\nFour\nFive\n"
    );

    root.io = io;
    root.draw();

    // One chunk only
    assert(root.text.texture.chunks.length == 1);

    // This one chunk must have been drawn
    io.assertTexture(root.text.texture.chunks[0], Vector2(), color("#fff"));

    // Add a lot more text
    io.nextFrame;
    root.text = root.text.repeat(30).joiner.text;
    root.draw();

    const textSize = root.text._sizeDots;

    // Make sure assumptions for this test are sound:
    assert(textSize.y > chunkSize * 2, "Generated text must span at least three chunks");
    assert(io.windowSize.y < chunkSize, "Window size must be smaller than chunk size");

    // This time, there should be more chunks
    assert(root.text.texture.chunks.length >= 3);

    // Only the first one would be drawn, however
    io.assertTexture(root.text.texture.chunks[0], Vector2(), color("#fff"));
    assert(io.textures.walkLength == 1);

    // And, only the first one should be generated
    assert(root.text.texture.chunks[0].isValid);
    assert(root.text.texture.chunks[1 .. $].all!((ref a) => !a.isValid));

    // Scroll just enough so that both chunks should be on screen
    io.nextFrame;
    root.scroll = chunkSize - 1;
    root.draw();

    // First two chunks must have been generated and drawn
    assert(root.text.texture.chunks[0 .. 2].all!((ref a) => a.isValid));
    assert(root.text.texture.chunks[2 .. $].all!((ref a) => !a.isValid));

    io.assertTexture(root.text.texture.chunks[0], Vector2(0, -root.scroll), color("#fff"));
    io.assertTexture(root.text.texture.chunks[1], Vector2(0, -root.scroll + chunkSize), color("#fff"));
    assert(io.textures.walkLength == 2);

    // Skip to third chunk, force regeneration
    io.nextFrame;
    root.scroll = 2 * chunkSize - 1;
    root.updateSize();
    root.draw();

    // Because of the resize, the first chunk must have been destroyed
    assert(root.text.texture.chunks[0 .. 1].all!((ref a) => !a.isValid));
    assert(root.text.texture.chunks[1 .. 3].all!((ref a) => a.isValid));
    assert(root.text.texture.chunks[3 .. $].all!((ref a) => !a.isValid));

    io.assertTexture(root.text.texture.chunks[1], Vector2(0, -root.scroll + chunkSize), color("#fff"));
    io.assertTexture(root.text.texture.chunks[2], Vector2(0, -root.scroll + chunkSize*2), color("#fff"));
    assert(io.textures.walkLength == 2);

}

unittest {

    import std.file;
    import fluid.text_input;

    auto root = textInput();
    root.draw();
    root.io.clipboard = readText(__FILE_FULL_PATH__);
    root.paste();
    root.draw();

}

/// Represents the distance between two points in in text.
struct TextInterval {

    /// Length of the interval in bytes.
    size_t length;

    /// Number of line breaks in this range; 0-indexed line number.
    size_t line;

    /// Number of characters since the last line break; 0-indexed column number.
    size_t column;

    this(size_t length, size_t line, size_t column) {

        this.length = length;
        this.line   = line;
        this.column = column;

    }

    /// Calculate the interval occupied by a range (rope or string).
    /// Params:
    ///     fragment = Fragment to measure.
    this(Range)(Range fragment) 
    if (isSomeChar!(ElementType!Range) && (hasLength!Range || isSomeString!Range))
    do {

        this.length = fragment.length;

        // Count lines in the string, find the length of the last line
        foreach (line; Typeface.lineSplitter(fragment)) {

            this.line++;
            this.column = line.length;

        }

        // Decrement line count
        if (this.line) this.line--;

    }

    @("An empty string creates an empty interval")
    unittest {

        assert(TextInterval("")       == TextInterval.init);
        assert(TextInterval(Rope("")) == TextInterval.init);

    }

    /// Sum the intervals. Order of operation matters — `other` should come later in text than `this`.
    /// Params:
    ///     other = Next interval; interval to merge with.
    /// Returns:
    ///     A new interval that is a sum of both intervals.
    TextInterval opBinary(string op : "+")(const TextInterval other) const {

        // If the other point has a line break, our column does not affect it
        // Add them only if there is no line break 
        const column = other.line
            ? other.column
            : other.column + column;

        return TextInterval(length + other.length, line + other.line, column);

    }

    ref TextInterval opOpAssign(string op : "+")(const TextInterval other) {

        return this = this + other;

    }

    /// Change the point of reference for this interval, as if skipping characters from the start of the string. This
    /// is the interval equivalent of `std.range.drop` or a `[n..$]` slice. 
    ///
    /// This function is an inverse of interval sum (+), where `head` is the left hand side argument, and the return 
    /// value is the right hand side argument.
    ///
    /// Returns:
    ///     This interval, but set relative to `head`.
    /// Params:
    ///     head = Point inside this interval to use as a reference.
    TextInterval dropHead(const TextInterval head) const
    in (this.length >= head.length, format!"`head` cannot be longer (%s) than `this` (%s)"(head.length, this.length))
    out (r; head + r == this)
    do {

        // If the head points to some line in the middle, the resulting column stays the same.
        //     [Lorem ipsum dolor sit amet, consectetur adipiscing 
        //     elit, sed do eiusmod tempor] incididunt ut labore et 
        //     dolore magna aliqua.
        //                        ^ this.column, return.column
        if (head.line != this.line) {
            return TextInterval(length - head.length, line - head.line, this.column);
        }

        // If the head points to the last line, however, the column will be a difference.
        //     [Lorem ipsum dolor sit amet, consectetur adipiscing 
        //     elit, sed do eiusmod tempor incididunt ut labore et 
        //     dolore magna] aliqua.
        //     head.column ^       ^ this.column
        else {
            return TextInterval(length - head.length, line - head.line, this.column - head.column);
        }

    }

}

/// Cache result matching a point in text to a `TextRuler`.
private struct CachedTextRuler {

    /// Point (interval from the start of the text) at which the measurement was made.
    TextInterval point;

    /// Ruler containing information about the current position in the text.
    TextRuler ruler;

    alias ruler this;

}

/// This is a cache storing instances of `TextRuler` corresponding to different positions in the same text. This makes
/// it possible to find screen position of any character in text by its index. It also maps each of these points to a 
/// line and column number combo, making it possible to query characters by their position in the grid.
///
/// Entries into the cache are made in intervals. The cache will return the last found cache entry rather than one 
/// directly corresponding to the queried character. To get an exact position, the text ruler can be advanced by 
/// measuring all characters in between.
private struct TextRulerCache {

    /// Ruler at the start of this range.
    TextRuler startRuler;

    /// Interval covered by this range.
    TextInterval interval;

    /// Left and right branch of this cache entry.
    TextRulerCache* left, right;

    /// Depth of this node.
    int depth = 1;

    debug (Fluid_CacheInvariants)
    invariant {

        if (left) {


            assert(start, "Right branch is null, but the left isn't");
            assert(startRuler is left.startRuler);
            assert(interval == left.interval + right.interval, 
                format!"Cache interval %s is not the sum of its members %s + %s"(interval, left.interval, 
                    right.interval));
            assert(depth == max(left.depth, right.depth) + 1);

        }

        else {
            
            assert(right is null, "Left branch is null, but the right isn't");
            assert(depth == 1);

        }

    }

    /// Initialize the cache with the given `TextRuler` parameters.
    this(Typeface typeface, float lineWidth = float.nan) {

        this(TextRuler(typeface, lineWidth));

    }

    this(TextRuler ruler) {

        this.startRuler = ruler;

    }

    private this(TextRuler ruler, TextInterval interval) {

        this.startRuler = ruler;
        this.interval = interval;

    }

    private this(TextRulerCache* left, TextRulerCache* right) {

        this.startRuler = left.startRuler;
        this.interval = left.interval + right.interval;
        this.left = left;
        this.right = right;
        this.depth = max(left.depth, right.depth) + 1;

    }

    private void recalculateDepth() {

        // isLeaf inlined to avoid invariants
        if (left)
            depth = max(left.depth, right.depth) + 1;
        else
            depth = 1;

    }

    /// Returns: True if this cache contains exactly one entry. In such case, it will not have any children nodes.
    bool isLeaf() const {

        return left is null;

    }

    /// Resize a fragment of text, recalculating offsets of rulers.
    /// Params:
    ///     start       = Distance between start of the text and start of both intervals.
    ///     oldInterval = Interval (size) to be replaced.
    ///     newInterval = Interval to be inserted.
    void updateInterval(TextInterval start, TextInterval oldInterval, TextInterval newInterval) {

        // Nothing to do
        if (oldInterval.length == 0 && newInterval.length == 0) return;

        const absoluteStart = start;
        const absoluteEnd = start + oldInterval;

        scope cache = &this;

        import std.stdio;
        debug writefln!"updating interval %s..%s -> %s"(absoluteStart, absoluteEnd, start + newInterval);
        debug writefln!"in cache: ..%s"(cache.interval);

        // Delete all entries in the range
        // TODO this could be far more efficient
        for (auto range = query(&this, absoluteStart.length); !range.empty;) {

            // Skip the first entry, it is not affected
            if (range.front.point.length <= absoluteStart.length) {
                range.popFront;
                continue;
            }

            import std.stdio;
            debug writefln!"  entry: %s -> %s"(range.front.point, range.front.point.length > absoluteEnd.length ? "keep" : "delete");

            // Skip entires after the range
            if (range.front.point.length > absoluteEnd.length) break;

            range.removeFront;

        }

        import std.stdio;
        debug writefln!"after removal:%(\n  %s%)"(query(&this, absoluteStart.length));
        debug writefln!"moving";

        // Find a relevant node, update intervals of all ancestors and itself
        // thus pushing or pulling subsequent nodes 
        if (absoluteEnd.length < cache.interval.length)
        while (true) {

            const oldEnd = start + oldInterval;
            const newEnd = start + newInterval;

            import std.stdio;
            debug writef!"  interval: %s (%s -> %s) -> "(cache.interval, oldEnd, newEnd);

            cache.interval = newEnd + cache.interval.dropHead(oldEnd);

            debug writefln!"%s"(cache.interval);

            // Found the deepest relevant node
            // `isLeaf` is inlined to keep invariants from running
            if (cache.left is null) break; 

            // Search for a node that can control the start of the interval; either exactly at the start, 
            // or shortly before it, just like `query()`
            if (start.length <= cache.left.interval.length) {
                cache = cache.left;
            }
            else {
                start = start.dropHead(cache.left.interval);
                cache = cache.right;
            }

        }

    }

    /// Insert a ruler into the cache.
    /// Params:
    ///     point = Point to place the ruler at; text interval preceding the ruler.
    ///     ruler = Ruler to insert.
    void insert(TextInterval point, TextRuler ruler) {

        // Detect appending
        if (point.length > interval.length) {

            append(point, ruler);
            return;

        }

        // Find a point in this cache to enter
        auto range = query(&this, point.length);
        auto cache = range.stack.back;
        auto foundPoint = range.front.point;

        // Found an exact match, replace it
        if (point == foundPoint) {

            range.front = ruler;
            return;

        }

        // Inserting between two points
        else {

            assert(cache.interval.length != 0, "Cache data invalid, failed to detect append");

            const oldInterval = cache.interval;

            // We're inserting in between two points; `leftInterval` is distance from the left to our point, 
            // `rightInterval` is the distance from our point to the next point. Total distance is `cache.interval`.
            //
            //   ~~~~~~~~~~~~ cache.interval ~~~~~~~~~~~~
            //   |  leftInterval     |  rightInterval   |  (relative)
            //   ^ left.startRuler   ^ right.startRuler
            //   ^ foundPoint        ^ point               (absolute)
            const leftInterval = point.dropHead(foundPoint);
            const rightInterval = cache.interval.dropHead(leftInterval);

            assert(foundPoint   + leftInterval == point);
            assert(leftInterval + rightInterval == cache.interval);

            auto left = new TextRulerCache(cache.startRuler, leftInterval);
            auto right = new TextRulerCache(ruler, rightInterval);

            *range.stack.back = TextRulerCache(left, right);

            assert(range.stack.back.startRuler == left.startRuler);
            assert(range.stack.back.interval == oldInterval);
            assert(range.stack.back.interval == leftInterval + rightInterval);

            range.updateDepth();
            rebalance();

        }

    }

    /// Append a ruler to the cache.
    /// Params:
    ///     point = Point to place the ruler at; text interval preceding the ruler. This must point beyond interval
    ///         covered by the cache.
    ///     ruler = Ruler to insert.
    private void append(TextInterval point, TextRuler ruler)
    in (point.length > interval.length)
    do {

        scope cache = &this;
        auto relativePoint = point;

        // Descend (isLeaf inlined for debugging performance)
        while (cache.left !is null) {

            // Update interval and depth
            cache.interval = relativePoint;
            cache.depth++;

            // Descend towards the right side
            relativePoint = relativePoint.dropHead(cache.left.interval);
            cache = cache.right;

        }

        // Insert the node
        auto left  = new TextRulerCache(cache.startRuler, relativePoint);
        auto right = new TextRulerCache(ruler, TextInterval.init);

        *cache = TextRulerCache(left, right);        
        rebalance();

    }

    /// Returns: True if this cache node is out of balance. 
    /// See_Also: `rebalance` to rebalance a node to improve its performance.
    bool isBalanced() const {

        if (isLeaf) return true;

        const diff = left.depth - right.depth;
                
        return -15 < diff && diff < 15;

    }

    /// Recreate the cache to redistribute the nodes in a more optimal way.
    void rebalance() {

        if (!isBalanced) {

            auto nodes = appender!(TextRulerCache*[])();

            // Collect all nodes
            for (auto range = query(&this, 0); !range.empty; range.popFront) {

                assert(range.stack.back.isLeaf);
                nodes ~= range.stack.back;

            }

            this = *merge(nodes[]);

        }

    }

    /// Returns: A new cache node compromising multiple cache nodes.
    /// Params:
    ///     nodes = Leaf nodes the new cache can be made up of. They must be ordered, so that their intervals will 
    ///         specify their relations.
    static TextRulerCache* merge(scope TextRulerCache*[] nodes) {

        if (nodes.length == 0)
            assert(false, "Given node list is empty");
        else if (nodes.length == 1)
            return nodes[0];
        else if (nodes.length == 2)
            return new TextRulerCache(nodes[0], nodes[1]);
        else
            return new TextRulerCache(
                merge(nodes[0   .. $/2]),
                merge(nodes[$/2 .. $])
            );
        
        
    }
    
}

/// Get the last `TextRuler` at the given index, or preceding it.
/// Params:
///     index = Index to search for.
/// Returns:
///     A `TextRuler` struct wrapper with an extra `point` field to indicate the location in text the point 
///     corresponds to.
private auto query(return scope TextRulerCache* cache, size_t index)
out (r; !r.empty)
out (r) {
    static assert(is(ElementType!(typeof(r)) : const CachedTextRuler), ElementType!(typeof(r)).stringof);
}
do {

    import std.container.dlist : DList;

    static struct CacheStackFrame {

        TextRulerCache* cache;

        /// True if this is a parent node, and it has descended into the right side.
        bool isRight;

        alias cache this;

    }

    /// This range iterates the cache tree in order while skipping all but the last element that precedes the index. 
    /// It builds  a stack, the last item of which points to the current element of the range. Since the cache is 
    /// a binary tree in which each node either has one or two children, the stack can only have three possible 
    /// states:
    ///
    /// * It is empty, and so is this range
    /// * It points to a leaf (which is a valid state for `front`)
    /// * The last item has two children, so it needs to descend.
    ///
    /// During descend, left nodes are chosen, unless the first item — the needle — is on the right side. When 
    /// ascending (`popFront`), right nodes are chosen as left nodes have already been tested. To make sure the 
    /// right side is not visited again, nodes are not pushed to the stack when their right side is. For example,
    /// when iterating through a node `A` which has children `B` and `C`, the stack is initialized to `[A]`. 
    /// Descend is first done into `B`, resulting in `[A, B]`. First `popFront` removes `B` and descends the right
    /// side of `A` replacing it with `C`. The stack is `[C]`.
    static struct TextRulerCacheRange {

        DList!CacheStackFrame stack;
        size_t needle;
        TextInterval offset;

        @safe:

        inout(CachedTextRuler) front() inout {
            return inout CachedTextRuler(
                offset,
                stack.back.startRuler
            );
        }

        /// Assign a new value to the front
        ref TextRuler front(TextRuler ruler) {

            stack.back.startRuler = ruler;

            // Update startRuler in all ancestors
            foreach (ancestor; stack[].retro.dropOne) {
                static assert(isPointer!(typeof(ancestor.cache)));

                // End as soon as an unaffected ancestor is reached
                if (ancestor.startRuler is ancestor.left.startRuler) break;
                
                ancestor.startRuler = ancestor.left.startRuler;

            }

            return stack.back.startRuler;

        }

        bool empty() const {
            return stack.empty;
        }

        void popFront() {

            assert(!empty);
            assert(stack.back.isLeaf);

            offset += stack.back.interval;

            // Remove the leaf (front)
            stack.removeBack();

            // Find any parent that has right right side unvisited
            // `isRight` means the parents has already descended into its right side
            while (!stack.empty && stack.back.isRight) {
                stack.removeBack();
            }
            if (stack.empty) return;

            auto ancestor = stack.back;

            // Remove the next node and descend into its right side
            stack.back.isRight = true;
            stack ~= CacheStackFrame(ancestor.right);
            descend();

        }

        /// Update depth of the current node. Iterates through all ancestors.
        void updateDepth() {

            // Update depth of every item in the stack
            foreach_reverse (item; stack) {
                item.recalculateDepth();
            }

        }

        /// Remove the entry at the front of the range from the cache and advance to the next item.
        ///
        /// This cannot be used to remove the first entry in the cache.
        void removeFront() {

            // TODO tests for this

            assert(!empty);
            assert(stack.back.isLeaf);

            // Can't remove the root
            assert(offset.length != 0, "Cannot remove the first item in the cache.");

            const front = stack.back;
            
            // Ascend back to the parent
            stack.removeBack();
            auto parent = stack.back;

            // The node we're removing is on the right side, replace it with the left
            if (front is parent.right) {

                const interval = parent.interval;

                *parent = *parent.left;
                parent.interval = interval;
                updateDepth();
                popFront();

            }

            // The node we're removing is on the left side
            else if (front is parent.left) {

                const offset = parent.left.interval;

                this.offset += offset;

                // Move the right side to replace it
                *parent = *parent.right;

                // Now to keep the right side in the correct place, the interval has to be added to whatever node 
                // precedes it. This means we must find an adjacent branch that goes leftwards. We will search our 
                // ancestors: one containing a preceding node will have `isRight` set to `true`, i.e. the current node
                // is in the right branch. 
                TextRulerCache* previous;
                foreach (ancestor; stack[].retro.dropOne) {

                    ancestor.recalculateDepth();

                    // Found the previous node already, just recalculate depth
                    if (previous) continue;

                    // Move the offset from the removed node to the previous leaf node
                    if (ancestor.isRight) {
                        previous = ancestor.left;
                        continue;
                    }
                
                    // Recalculate the start and interval
                    ancestor.startRuler = ancestor.left.startRuler;
                    ancestor.interval = ancestor.left.interval + ancestor.right.interval;

                }

                assert(previous);

                // Descend into the preceding branch (always going right), expanding the interval of every node until 
                // we hit a leaf. 
                while (previous) {
                    previous.interval += offset;
                    previous = previous.right;
                }

                descend();

                assert(stack.back.isLeaf);

            }

            else assert(false);

        }

        /// Advance the range to the next leaf
        private void descend() {

            while (!stack.back.isLeaf) {

                auto front = stack.back;

                // Enter the left side, unless we know the needle is in the right side
                if (needle < offset.length + front.left.interval.length) {

                    stack.back.isRight = false;
                    stack ~= CacheStackFrame(front.left);

                }

                // Enter the right side
                else {

                    stack.back.isRight = true;
                    stack ~= CacheStackFrame(front.right);
                    offset += front.left.interval;

                }

            }

        }

    }
    
    auto ruler = TextRulerCacheRange(
        DList!CacheStackFrame(
            CacheStackFrame(cache)
        ),
        index
    );
    ruler.descend();

    return ruler;

}

@("Query on a leaf cache returns the first item")
unittest {

    auto cache = new TextRulerCache();

    assert(cache.query(0).equal([TextRuler.init]));
    assert(cache.query(1).equal([TextRuler.init]));
    assert(cache.query(10).equal([TextRuler.init]));

    auto ruler = TextRuler(Typeface.defaultTypeface, 10);
    *cache = TextRulerCache(ruler);

    assert(cache.query(0).equal([ruler]));
    assert(cache.query(1).equal([ruler]));
    assert(cache.query(10).equal([ruler]));

}

@("TextRulerCache.insert works")
unittest {

    auto cache = new TextRulerCache();
    auto typeface = Typeface.defaultTypeface;

    auto points = [
        CachedTextRuler(TextInterval( 0, 0,  0), TextRuler(typeface, 1)),
        CachedTextRuler(TextInterval( 5, 0,  5), TextRuler(typeface, 2)),
        CachedTextRuler(TextInterval(10, 0, 10), TextRuler(typeface, 3)),
        CachedTextRuler(TextInterval(15, 1,  3), TextRuler(typeface, 4)),
        CachedTextRuler(TextInterval(20, 1,  8), TextRuler(typeface, 5)),
        CachedTextRuler(TextInterval(25, 2,  1), TextRuler(typeface, 6)),
    ];

    // 12 character long lines, snapshots every 5 characters
    cache.insert(points[0].tupleof);
    cache.insert(points[1].tupleof);
    cache.insert(points[2].tupleof);
    cache.insert(points[3].tupleof);
    cache.insert(points[4].tupleof);
    cache.insert(points[5].tupleof);

    assert(cache.query( 0).equal(points));
    assert(cache.query( 1).equal(points));
    
    assert(cache.query( 7).equal(points[1..$]));
    assert(cache.query(30).equal(points[5..$]));
    assert(cache.query(18).equal(points[3..$]));
    assert(cache.query(15).equal(points[3..$]));

    auto newPoints = [
        CachedTextRuler(TextInterval( 0, 0,  0), TextRuler(typeface, 7)),
        CachedTextRuler(TextInterval(12, 1,  0), TextRuler(typeface, 8)),
        CachedTextRuler(TextInterval(24, 2,  0), TextRuler(typeface, 9)),
    ];

    points = points[1..$];
    points ~= newPoints;
    sort!"a.point.length < b.point.length"(points);

    // Insert a few more snapshots
    cache.insert(newPoints[2].tupleof);
    cache.insert(newPoints[0].tupleof);
    cache.insert(newPoints[1].tupleof);
    
    assert(cache.query(0).equal(points));

}

@("Text automatically creates TextRulerCache entries")
unittest {

    import fluid.label;

    auto root = label(nullTheme, "Lorem ipsum dolor sit amet, consectetur " 
        ~ "adipiscing elit, sed do eiusmod tempor " 
        ~ "incididunt ut labore et dolore magna " 
        ~ "aliqua. Ut enim ad minim veniam, quis " 
        ~ "nostrud exercitation ullamco laboris " 
        ~ "nisi ut aliquip ex ea commodo consequat.\n" 
        ~ "\n" 
        ~ "Duis aute irure dolor in reprehenderit " 
        ~ "in voluptate velit esse cillum dolore " 
        ~ "eu fugiat nulla pariatur. Excepteur " 
        ~ "sint occaecat cupidatat non proident, " 
        ~ "sunt in culpa qui officia deserunt " 
        ~ "mollit anim id est laborum.\n");

    assert(root.text._updateRangeStart == 0);
    assert(root.text._updateRangeEnd == root.text.length);

    root.draw();

    auto typeface = root.style.getTypeface;
    auto space = root.io.windowSize;

    assert(root.text[232] == '\n');
    assert(query(&root.text._cache, 0).map!"a.point".equal([
        TextInterval(  0, 0,   0),
        TextInterval(132, 0, 132),  // Past 128 characters, + "nim ", next checkpoint 132+128
        TextInterval(272, 2,  39),  // Past 260 characters, + "prehenderit ", line begins at 233
        TextInterval(402, 2, 169),  // Past 400 characters, + "i "
        TextInterval(root.text.length, 3, 0),
    ]));

    version (none) {
        // Why isn't this equal?
        auto ruler = TextRuler(typeface, space.x);
        typeface.measure(ruler, "");
        assert(query(&root.text._cache,   0).front == ruler);
    }
    {
        auto ruler = TextRuler(typeface, space.x);
        typeface.measure(ruler, root.text[0..132]);
        assert(query(&root.text._cache, 132).front == ruler);
    }
    {
        auto ruler = TextRuler(typeface, space.x);
        typeface.measure(ruler, root.text[0..272]);
        assert(query(&root.text._cache, 272).front == ruler);
    }
    {
        auto ruler = TextRuler(typeface, space.x);
        typeface.measure(ruler, root.text[0..402]);
        assert(query(&root.text._cache, 402).front == ruler);
    }

}

@("Text can update TextRulerCache entries")
unittest {

    import fluid.label;

    auto root = label(nullTheme, "Lorem ipsum dolor sit amet, consectetur " 
        ~ "adipiscing elit, sed do eiusmod tempor " 
        ~ "incididunt ut labore et dolore magna " 
        ~ "aliqua. Ut enim ad minim veniam, quis " 
        ~ "nostrud exercitation ullamco laboris " 
        ~ "nisi ut aliquip ex ea commodo consequat.\n" 
        ~ "\n" 
        ~ "Duis aute irure dolor in reprehenderit " 
        ~ "in voluptate velit esse cillum dolore " 
        ~ "eu fugiat nulla pariatur. Excepteur " 
        ~ "sint occaecat cupidatat non proident, " 
        ~ "sunt in culpa qui officia deserunt " 
        ~ "mollit anim id est laborum.\n");

    root.draw();

    // Same data as in the last test
    assert(query(&root.text._cache, 0).map!"a.point".equal([
        TextInterval(  0, 0,   0),
        TextInterval(132, 0, 132),
        TextInterval(272, 2,  39),
        TextInterval(402, 2, 169),
        TextInterval(root.text.length, 3, 0),
    ]));

    // Replace enough text to destroy two intervals
    root.text[130..280] = 'a'.repeat(150).array;

    assert(root.tree.resizePending);
    
    root.draw();

    assert(query(&root.text._cache, 0).map!"a.point".equal([
        TextInterval(  0, 0,   0),
        TextInterval(285, 0, 285),  // 132 and 272 are gone
        TextInterval(402, 0, 402),  // Line breaks were replaced
        TextInterval(root.text.length, 1, 0),
    ]));

    assert(root.text[284..290] == " velit");

}

@("Text updates cache intervals on write")
unittest {

    import fluid.label;

    auto root = label(nullTheme, "import fluid;\n"
        ~ "void main() {\n"
        ~ "    run(\n"
        ~ "        label(\"Hello, World!\")\n"
        ~ "    );\n"
        ~ "}\n");

    auto typeface = root.pickStyle.getTypeface;

    // Clear cache
    root.text.reload();
    root.text._cache.insert(TextInterval( 0, 0,  0), TextRuler(typeface, 0));
    root.text._cache.insert(TextInterval(14, 1,  0), TextRuler(typeface, 1));
    root.text._cache.insert(TextInterval(28, 2,  0), TextRuler(typeface, 2));
    root.text._cache.insert(TextInterval(37, 3,  0), TextRuler(typeface, 3));
    root.text._cache.insert(TextInterval(67, 3, 30), TextRuler(typeface, 4));
    root.text._cache.insert(TextInterval(68, 4,  0), TextRuler(typeface, 5));
    root.text._cache.insert(TextInterval(75, 5,  0), TextRuler(typeface, 6));

    const start = 37 + `        label("Hello, `.length;

    root.text[start .. start + "World".length] = "everyone!\nHave a nice day";

    assert(query(&root.text._cache, 0).equal([
         CachedTextRuler(TextInterval( 0, 0,  0), TextRuler(typeface, 0)),
         CachedTextRuler(TextInterval(14, 1,  0), TextRuler(typeface, 1)),
         CachedTextRuler(TextInterval(28, 2,  0), TextRuler(typeface, 2)),
         CachedTextRuler(TextInterval(37, 3,  0), TextRuler(typeface, 3)),
         CachedTextRuler(TextInterval(87, 4, 18), TextRuler(typeface, 4)),
         CachedTextRuler(TextInterval(88, 5,  0), TextRuler(typeface, 5)),
         CachedTextRuler(TextInterval(95, 6,  0), TextRuler(typeface, 6)),
    ]));
    
}

@("Cache node removal works")
@trusted 
unittest {

    auto typeface = Typeface.defaultTypeface;

    // Cache with entries at 0 and 10
    TextRulerCache make() {
        auto left  = new TextRulerCache(TextRuler(typeface, 1), TextInterval( 6, 1, 0));
        auto right = new TextRulerCache(TextRuler(typeface, 2), TextInterval( 4, 1, 0));
        return TextRulerCache(left, right);
    }

    {
        // Remove entry at 10
        auto root = make();
        query(&root, 10).removeFront;

        // Only the first entry should survive
        assert(query(&root, 0).equal([
            CachedTextRuler(TextInterval(0, 0, 0), TextRuler(typeface, 1)),
        ]));
    }

    // Removing a node in the middle
    {
        auto left = make();
        auto right = make();
        auto root = TextRulerCache(&left, &right);

        // Remove a right side node ((0, 6), (10, 16)) -> (0, (10, 16))
        query(&root, 6).removeFront;

        assert(query(&root, 0).equal([
            CachedTextRuler(TextInterval(0,  0, 0), TextRuler(typeface, 1)),
            CachedTextRuler(TextInterval(10, 2, 0), TextRuler(typeface, 1)),
            CachedTextRuler(TextInterval(16, 3, 0), TextRuler(typeface, 2)),
        ]));

        // Remove a left side node (0, (10, 16)) -> (0, 16)
        query(&root, 10).removeFront;

        assert(query(&root, 0).equal([
            CachedTextRuler(TextInterval(0,  0, 0), TextRuler(typeface, 1)),
            CachedTextRuler(TextInterval(16, 3, 0), TextRuler(typeface, 2)),
        ]));
        
    }

    // Clearing it out
    {
        TextRulerCache[5] nodes = make();
        auto root = TextRulerCache(&nodes[0], 
            new TextRulerCache(
                &nodes[1],
                new TextRulerCache(
                    &nodes[2],
                    new TextRulerCache(
                        &nodes[3],
                        &nodes[4],
                    )
                )
            )
        );

        assert(query(&root, 0).equal([
            CachedTextRuler(TextInterval( 0, 0, 0), TextRuler(typeface, 1)),
            CachedTextRuler(TextInterval( 6, 1, 0), TextRuler(typeface, 2)),
            CachedTextRuler(TextInterval(10, 2, 0), TextRuler(typeface, 1)),
            CachedTextRuler(TextInterval(16, 3, 0), TextRuler(typeface, 2)),
            CachedTextRuler(TextInterval(20, 4, 0), TextRuler(typeface, 1)),
            CachedTextRuler(TextInterval(26, 5, 0), TextRuler(typeface, 2)),
            CachedTextRuler(TextInterval(30, 6, 0), TextRuler(typeface, 1)),
            CachedTextRuler(TextInterval(36, 7, 0), TextRuler(typeface, 2)),
            CachedTextRuler(TextInterval(40, 8, 0), TextRuler(typeface, 1)),
            CachedTextRuler(TextInterval(46, 9, 0), TextRuler(typeface, 2)),
        ]));

        for (auto range = query(&root, 6); !range.empty; range.removeFront) { }

        assert(query(&root, 0).equal([
            CachedTextRuler(TextInterval( 0, 0, 0), TextRuler(typeface, 1)),
        ]));
    }

}

@("Text can be filled and cleared in a loop")
unittest {

    import fluid.label;

    auto word = 'a'.repeat(256);
    const text = Rope(word.repeat(2).join(" "));

    auto root = label("");

    foreach (i; 0..100) {

        root.text = text;
        root.draw();
        assert(query(&root.text._cache, 0).walkLength > 1);

        root.text = "";
        root.draw();
        assert(query(&root.text._cache, 0).walkLength == 1);

    }

}

/// `wordFront` and `wordBack` get the word at the beginning or end of given string, respectively.
///
/// A word is a streak of consecutive characters — non-whitespace, either all alphanumeric or all not — followed by any
/// number of whitespace.
///
/// Params:
///     text = Text to scan for the word.
///     excludeWhite = If true, whitespace will not be included in the word.
T wordFront(T)(T text, bool excludeWhite = false) {

    import std.utf : codeLength;

    size_t length;

    T result() { return text[0..length]; }
    T remaining() { return text[length..$]; }

    while (remaining != "") {

        // Get the first character
        const lastChar = remaining.decodeFrontStatic;

        // Exclude white characters if enabled
        if (excludeWhite && lastChar.isWhite) break;

        length += lastChar.codeLength!(typeof(text[0]));

        // Stop if empty
        if (remaining == "") break;

        const nextChar = remaining.decodeFrontStatic;

        // Stop if the next character is a line feed
        if (nextChar.only.chomp.empty && !only(lastChar, nextChar).equal("\r\n")) break;

        // Continue if the next character is whitespace
        // Includes any case where the previous character is followed by whitespace
        else if (nextChar.isWhite) continue;

        // Stop if whitespace follows a non-white character
        else if (lastChar.isWhite) break;

        // Stop if the next character has different type
        else if (lastChar.isAlphaNum != nextChar.isAlphaNum) break;

    }

    return result;

}

/// ditto
T wordBack(T)(T text, bool excludeWhite = false) {

    import std.utf : codeLength;

    size_t length = text.length;

    T result() { return text[length..$]; }
    T remaining() { return text[0..length]; }

    while (remaining != "") {

        // Get the first character
        const lastChar = remaining.decodeBackStatic;

        // Exclude white characters if enabled
        if (excludeWhite && lastChar.isWhite) break;

        length -= lastChar.codeLength!(typeof(text[0]));

        // Stop if empty
        if (remaining == "") break;

        const nextChar = remaining.decodeBackStatic;

        // Stop if the character is a line feed
        if (lastChar.only.chomp.empty && !only(nextChar, lastChar).equal("\r\n")) break;

        // Continue if the current character is whitespace
        // Inverse to `wordFront`
        else if (lastChar.isWhite) continue;

        // Stop if whitespace follows a non-white character
        else if (nextChar.isWhite) break;

        // Stop if the next character has different type
        else if (lastChar.isAlphaNum != nextChar.isAlphaNum) break;

    }

    return result;

}

/// `std.utf.decodeFront` and `std.utf.decodeBack` variants that do not mutate the range
dchar decodeFrontStatic(T)(T range) @trusted {

    import std.utf : decodeFront;

    return range.decodeFront;

}

/// ditto
dchar decodeBackStatic(T)(T range) @trusted {

    import std.utf : decodeBack;

    return range.decodeBack;

}

unittest {

    assert("hello world!".wordFront == "hello ");
    assert("hello, world!".wordFront == "hello");
    assert("hello world!".wordBack == "!");
    assert("hello world".wordBack == "world");
    assert("hello ".wordBack == "hello ");

    assert("witaj świecie!".wordFront == "witaj ");
    assert(" świecie!".wordFront == " ");
    assert("świecie!".wordFront == "świecie");
    assert("witaj świecie!".wordBack == "!");
    assert("witaj świecie".wordBack == "świecie");
    assert("witaj ".wordBack == "witaj ");

    assert("Всем привет!".wordFront == "Всем ");
    assert("привет!".wordFront == "привет");
    assert("!".wordFront == "!");

    // dstring
    assert("Всем привет!"d.wordFront == "Всем "d);
    assert("привет!"d.wordFront == "привет"d);
    assert("!"d.wordFront == "!"d);

    assert("Всем привет!"d.wordBack == "!"d);
    assert("Всем привет"d.wordBack == "привет"d);
    assert("Всем "d.wordBack == "Всем "d);

    // Whitespace exclusion
    assert("witaj świecie!".wordFront(true) == "witaj");
    assert(" świecie!".wordFront(true) == "");
    assert("witaj świecie".wordBack(true) == "świecie");
    assert("witaj ".wordBack(true) == "");

}

unittest {

    assert("\nabc\n".wordFront == "\n");
    assert("\n  abc\n".wordFront == "\n  ");
    assert("abc\n".wordFront == "abc");
    assert("abc  \n".wordFront == "abc  ");
    assert("  \n".wordFront == "  ");
    assert("\n     abc".wordFront == "\n     ");

    assert("\nabc\n".wordBack == "\n");
    assert("\nabc".wordBack == "abc");
    assert("abc  \n".wordBack == "\n");
    assert("abc  ".wordFront == "abc  ");
    assert("\nabc\n  ".wordBack == "\n  ");
    assert("\nabc\n  a".wordBack == "a");

    assert("\r\nabc\r\n".wordFront == "\r\n");
    assert("\r\n  abc\r\n".wordFront == "\r\n  ");
    assert("abc\r\n".wordFront == "abc");
    assert("abc  \r\n".wordFront == "abc  ");
    assert("  \r\n".wordFront == "  ");
    assert("\r\n     abc".wordFront == "\r\n     ");

    assert("\r\nabc\r\n".wordBack == "\r\n");
    assert("\r\nabc".wordBack == "abc");
    assert("abc  \r\n".wordBack == "\r\n");
    assert("abc  ".wordFront == "abc  ");
    assert("\r\nabc\r\n  ".wordBack == "\r\n  ");
    assert("\r\nabc\r\n  a".wordBack == "a");

}
