module fluid.text;

import std.math;
import std.range;
import std.traits;
import std.string;
import std.algorithm;

import fluid.node;
import fluid.style;
import fluid.utils;
import fluid.backend;
import fluid.typeface;

public import fluid.rope;


@safe:


/// Create a Text struct with given range as a text layer map.
StyledText!StyleRange mapText(StyleRange)(Node node, const char[] text, StyleRange range) {

    return typeof(return)(node, text, range);

}

alias Text = StyledText!();

/// Draws text: handles updates, formatting and styling.
struct StyledText(StyleRange = TextStyleSlice[]) {

    static assert(isForwardRange!StyleRange,
        "StyleRange must be a valid forward range of TextStyleSlices");
    static assert(is(ElementType!StyleRange : TextStyleSlice),
        "StyleRange must be a valid forward range of TextStyleSlices");

    public {

        /// Node owning this text struct.
        Node node;

        /// Texture generated by the struct.
        CompositeTexture texture;

        /// Underlying text.
        Rope value;

        /// Range assigning slices of text to styles by index. A single text can have up to 256 different styles.
        ///
        /// Ranges should not overlap, and must be ordered by `start`. If a piece of text is not matched, it is assumed
        /// to belong to style 0.
        StyleRange styleMap;

        /// If true, enables optimizations for frequently edited text.
        bool hasFastEdits;

        /// Indent width, in pixels.
        float indentWidth = 32;

    }

    private {

        /// Text bounding box size, in dots.
        Vector2 _sizeDots;

        /// If true, text will be wrapped if it doesn't fit available space.
        bool _wrap;

    }

    alias minSize = size;
    alias value this;

    static if (is(StyleRange == TextStyleSlice[]))
    this(Node node, Rope text) {

        this.node = node;
        opAssign(text);

    }

    this(Node node, Rope text, StyleRange styleMap) {

        this.styleMap = styleMap;
        this.node = node;
        opAssign(text);

    }

    static if (is(StyleRange == TextStyleSlice[]))
    this(Node node, const(char)[] text) {

        this.node = node;
        opAssign(text);

    }

    this(Node node, const(char)[] text, StyleRange styleMap) {

        this.styleMap = styleMap;
        this.node = node;
        opAssign(text);

    }

    /// Copy the text, clear ownership and texture.
    this(StyledText text) const {

        this.node = null;
        this.value = text.value;
        this.styleMap = text.styleMap.save;

    }

    inout(FluidBackend) backend() inout

        => node.tree.backend;

    Rope opAssign(Rope text) {

        // Identical; no change is to be made
        if (text is value) return text;

        // Request an update
        node.updateSize();
        return value = text;


    }

    const(char)[] opAssign(const(char)[] text) {

        // Ignore if there's no change to be made
        if (text == value) return text;

        // Request update otherwise
        node.updateSize;
        value = text;
        return text;

    }

    void opOpAssign(string operator)(const(char)[] text) {

        node.updateSize;
        mixin("value ", operator, "= text;");

    }

    /// Get the size of the text.
    Vector2 size() const {

        const scale = backend.hidpiScale;

        return Vector2(
            _sizeDots.x / scale.x,
            _sizeDots.y / scale.y,
        );

    }

    alias minSize = size;

    /// Set new bounding box for the text.
    void resize() {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const dpi = backend.dpi;
        const scale = backend.hidpiScale;

        style.setDPI(dpi);
        typeface.indentWidth = cast(int) (indentWidth * scale.x);

        // Update the size
        _sizeDots = typeface.measure(value);
        _wrap = false;
        clearTextures();

    }

    /// Set new bounding box for the text; wrap the text if it doesn't fit in boundaries.
    void resize(alias splitter = Typeface.defaultWordChunks)(Vector2 space, bool wrap = true) {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const dpi = backend.dpi;
        const scale = backend.hidpiScale;

        // Apply DPI
        style.setDPI(dpi);
        typeface.indentWidth = cast(int) (indentWidth * scale.x);
        space.x *= scale.x;
        space.y *= scale.y;

        // Update the size
        _sizeDots = style.getTypeface.measure!splitter(space, value, wrap);
        _wrap = wrap;
        clearTextures();

    }

    /// Reset the texture, destroying it and replacing it with a blank.
    void clearTextures() {

        texture.format = Image.Format.palettedAlpha;
        texture.resize(_sizeDots, hasFastEdits);

    }

    /// Generate the textures, if not already generated.
    ///
    /// Params:
    ///     chunks = Indices of chunks that need to be regenerated.
    ///     position = Position of the text; If given, only on-screen chunks will be generated.
    void generate(Vector2 position) {

        generate(texture.visibleChunks(position, backend.windowSize));

    }

    /// ditto
    void generate(R)(R chunks) @trusted {

        // Empty, nothing to do
        if (chunks.empty) return;

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const dpi = backend.dpi;
        const scale = backend.hidpiScale;

        // Apply sizing settings
        style.setDPI(dpi);
        typeface.indentWidth = cast(int) (indentWidth * scale.x);

        // Ignore chunks which have already been generated
        auto newChunks = chunks
            .filter!(index => !texture.chunks[index].isValid);

        // No chunks to render, stop here
        if (newChunks.empty) return;

        // Clear the chunks
        foreach (chunkIndex; newChunks) {

            texture.clearImage(chunkIndex);

        }

        auto ruler = TextRuler(typeface, _sizeDots.x);

        // Copy the layer range, make it infinite
        auto styleMap = this.styleMap.save.chain(TextStyleSlice.init.repeat);

        // Run through the text
        foreach (index, line; Typeface.lineSplitterIndex(value)) {

            ruler.startLine();

            // Split on words
            // TODO use the splitter provided when resizing
            foreach (word, penPosition; Typeface.eachWord(ruler, line, _wrap)) {

                const wordEnd = index + word.length;

                // Split the word based on the layer map
                while (index != wordEnd) {

                    const remaining = wordEnd - index;
                    auto wordFragment = word[$ - remaining .. $];
                    auto range = styleMap.front;

                    // Advance the layer map if exceeded the end
                    if (index >= range.end) {
                        styleMap.popFront;
                        continue;
                    }

                    ubyte styleIndex;

                    // Match found here
                    if (index >= range.start) {

                        // Find the end of the range
                        const end = min(wordEnd, range.end) - index;
                        wordFragment = wordFragment[0 .. end];
                        styleIndex = range.styleIndex;

                    }

                    // Match found later
                    else if (range.start < wordEnd) {

                        wordFragment = wordFragment[0 .. range.start - index];

                    }

                    const currentPenPosition = penPosition;

                    // Draw the fragment to selected chunks
                    foreach (chunkIndex; newChunks) {

                        const chunkRect = texture.chunkRectangle(chunkIndex);

                        // Ignore chunks this word is not in the bounds of
                        const relevant = chunkRect.contains(ruler.caret(currentPenPosition).start)
                            || chunkRect.contains(ruler.caret.end);

                        if (!relevant) continue;

                        // Get pen position relative to this chunk
                        auto relativePenPosition = currentPenPosition - chunkRect.start;

                        // Note: relativePenPosition is passed by ref
                        auto image = texture.chunks[chunkIndex].image;
                        typeface.drawLine(image, relativePenPosition, wordFragment, styleIndex);

                        // Update the pen position; Result of this should be the same for each chunk
                        penPosition = relativePenPosition + chunkRect.start;

                    }

                    // Update the index
                    index += wordFragment.length;

                }

            }

        }

        // Load the updated chunks
        foreach (chunkIndex; newChunks) {

            texture.upload(backend, chunkIndex, dpi);

        }

    }

    /// Draw the text.
    void draw(const Style style, Vector2 position) {

        scope const Style[1] styles = [style];

        draw(styles, position);

    }

    /// ditto
    void draw(scope const Style[] styles, Vector2 position)
    in (styles.length >= 1, "At least one style must be passed to draw(Style[], Vector2)")
    do {

        import std.math;
        import fluid.utils;

        const rectangle = Rectangle(position.tupleof, size.tupleof);
        const screen = Rectangle(0, 0, node.io.windowSize.tupleof);

        // Ignore if offscreen
        if (!overlap(rectangle, screen)) return;

        // Regenerate visible textures
        generate(position);

        // Make space in the texture's palette
        if (texture.palette.length != styles.length)
            texture.palette.length = styles.length;

        // Fill it with text colors of each of the styles
        styles.map!"a.textColor".copy(texture.palette);

        // Draw the texture if present
        texture.drawAlign(backend, rectangle);

    }

    /// ditto
    deprecated("Use draw(Style, Vector2) instead. Hint: Use fluid.utils.start(Rectangle) to get the position vector.")
    void draw(const Style style, Rectangle rectangle) {

        // Should this "crop" the result?

        draw(style, Vector2(rectangle.x, rectangle.y));

    }

    string toString() const {

        import std.conv : to;

        return value.to!string;

    }

}

struct TextStyleSlice {

    /// Start and end of this slice. Start is inclusive, end is exclusive. The range may exceed text boundaries.
    auto start = size_t.max;

    /// ditto
    auto end = size_t.max;

    invariant(start <= end);

    /// Index of the style to be assigned to the text covered by this slice.
    ubyte styleIndex;

    ptrdiff_t opCmp(const TextStyleSlice that) const {

        return cast(ptrdiff_t) this.start - cast(ptrdiff_t) that.start;

    }

    /// Apply some offset to the slice.
    TextStyleSlice offset(int offset) const {

        return TextStyleSlice(start + offset, end + offset, styleIndex);

    }

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();
    auto text = Text(root, "Hello, green world!");

    // Set colors for each part
    Style[4] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");
    styles[2].textColor = color("#55b9ff");
    styles[3].textColor = color("#0058f1");

    // Define regions
    text.styleMap = [
        TextStyleSlice(7, 12, 1),   // green
        TextStyleSlice(13, 14, 2),  // w
        TextStyleSlice(14, 15, 3),  // o
        TextStyleSlice(15, 16, 2),  // r
        TextStyleSlice(16, 17, 3),  // l
        TextStyleSlice(17, 18, 2),  // d
    ];

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize();
    text.draw(styles, Vector2(0, 0));

    // Make sure the texture was drawn with the correct color
    io.assertTexture(text.texture.chunks[0], Vector2(), color("#fff"));

    foreach (i; 0..4) {

        assert(text.texture.chunks[0].palette[i] == styles[i].textColor);
        assert(text.texture.palette[i] == styles[i].textColor);

    }

    // TODO Is there a way to reliably test if the result was drawn properly? Sampling specific pixels maybe?

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto styleMap = recurrence!"a[n-1] + 1"(0)
        .map!(a => TextStyleSlice(a, a+1, cast(ubyte) (a % 2)));

    auto text = mapText(root, "Hello, World!", styleMap);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(50, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto styleMap = [
        TextStyleSlice(2, 11, 1),
    ];

    auto text = mapText(root, "Hello, World!", styleMap);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(60, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    Style[2] styles;
    auto root = vspace();
    auto styleMap = [
        TextStyleSlice(0, 0, 1),
    ];
    auto text = mapText(root, "Hello, World!", styleMap);

    root.draw();
    text.resize();
    text.draw(styles, Vector2(0, 0));

}

/// A composite texture splits a larger area onto smaller chunks, making rendering large pieces of text more efficient.
struct CompositeTexture {

    enum maxChunkSize = 1024;

    struct Chunk {

        TextureGC texture;
        Image image;
        bool isValid;

        alias texture this;

    }

    /// Format of the texture.
    Image.Format format;

    /// Total size of the texture.
    Vector2 size;

    /// Underlying textures.
    ///
    /// Each texture, except for the last in each column or row, has the size of maxChunkSize on each side. The last
    /// texture in each row and column may have reduced width and height respectively.
    Chunk[] chunks;

    /// Palette to use for the texture, if relevant.
    Color[] palette;

    private bool _alwaysMax;

    this(Vector2 size, bool alwaysMax = false) {

        resize(size, alwaysMax);

    }

    /// Set a new size for the texture; recalculate the chunk number
    /// Params:
    ///     size      = New size of the texture.
    ///     alwaysMax = Always give chunks maximum size. Improves performance in nodes that frequently change their
    ///         content.
    void resize(Vector2 size, bool alwaysMax = false) {

        this.size = size;
        this._alwaysMax = alwaysMax;

        const chunkCount = columns * rows;

        this.chunks.length = chunkCount;

        // Invalidate the chunks
        foreach (ref chunk; chunks) {

            chunk.isValid = false;

        }

    }

    size_t chunkCount() const {

        return chunks.length;

    }

    size_t columns() const {

        return cast(size_t) ceil(size.x / maxChunkSize);

    }

    size_t rows() const {

        return cast(size_t) ceil(size.y / maxChunkSize);

    }

    size_t column(size_t i) const {

        return i % columns;

    }

    size_t row(size_t i) const {

        return i / columns;

    }

    /// Get the expected size of the chunk at given index
    Vector2 chunkSize(size_t i) const {

        // Return max chunk size if requested
        if (_alwaysMax)
            return Vector2(maxChunkSize, maxChunkSize);

        const x = column(i);
        const y = row(i);

        // Reduce size for last column
        const width = x + 1 == columns
            ? size.x % maxChunkSize
            : maxChunkSize;

        // Reduce size for last row
        const height = y + 1 == rows
            ? size.y % maxChunkSize
            : maxChunkSize;

        return Vector2(width, height);

    }

    /// Get index of the chunk at given X or Y.
    size_t index(size_t x, size_t y) const
    in (x < columns)
    in (y < rows)
    do {

        return x + y * columns;

    }

    /// Get position of the given chunk in dots.
    Vector2 chunkPosition(size_t i) const {

        const x = column(i);
        const y = row(i);

        return maxChunkSize * Vector2(x, y);

    }

    /// Get the rectangle of the given chunk in dots.
    /// Params:
    ///     i      = Index of the chunk.
    ///     offset = Translate the resulting rectangle by this vector.
    Rectangle chunkRectangle(size_t i, Vector2 offset = Vector2()) const {

        return Rectangle(
            (chunkPosition(i) + offset).tupleof,
            chunkSize(i).tupleof,
        );

    }

    /// Get a range of indices for all currently visible chunks.
    const visibleChunks(Vector2 position, Vector2 windowSize) {

        const offset = -position;
        const end = offset + windowSize;

        ptrdiff_t positionToIndex(alias round)(float position, ptrdiff_t limit) {

            const index = cast(ptrdiff_t) round(position / maxChunkSize);

            return index.clamp(0, limit);

        }

        const rowStart = positionToIndex!floor(offset.y, rows);
        const rowEnd = positionToIndex!ceil(end.y, rows);
        const columnStart = positionToIndex!floor(offset.x, columns);
        const columnEnd = positionToIndex!ceil(end.x, columns);

        // For each row
        return iota(rowStart, rowEnd)
            .map!(row =>

                // And each column
                iota(columnStart, columnEnd)

                    // Get its index
                    .map!(column => index(column, row)))
            .joiner;

    }

    /// Clear the image of the given chunk, making it transparent.
    void clearImage(size_t i) {

        const size = chunkSize(i);
        const width = cast(int) size.x;
        const height = cast(int) size.y;

        // Check if the size of the chunk has changed
        const sizeMatches = chunks[i].image.width == width
            && chunks[i].image.height == height;

        // Size matches, reuse the image
        if (sizeMatches)
            chunks[i].image.clear(PalettedColor.init);

        // No match, generate a new image
        else final switch (format) {

            case format.rgba:
                chunks[i].image = generateColorImage(width, height, color("#0000"));
                return;

            case format.palettedAlpha:
                chunks[i].image = generatePalettedImage(width, height, 0);
                return;

            case format.alpha:
                chunks[i].image = generateAlphaMask(width, height, 0);
                return;

        }

    }

    /// Update the texture of a given chunk using its corresponding image.
    void upload(FluidBackend backend, size_t i, Vector2 dpi) @trusted {

        const sizeMatches = chunks[i].image.width == chunks[i].texture.width
            && chunks[i].image.height == chunks[i].texture.height;

        // Size is the same as before, update the texture
        if (sizeMatches) {

            assert(chunks[i].texture.backend !is null);
            debug assert(backend is chunks[i].texture.backend,
                .format!"Backend mismatch %s != %s"(backend, chunks[i].texture.backend));

            chunks[i].texture.update(chunks[i].image);

        }

        // No match, create a new texture
        else {

            chunks[i].texture = TextureGC(backend, chunks[i].image);

        }

        // Update DPI
        chunks[i].texture.dpiX = cast(int) dpi.x;
        chunks[i].texture.dpiY = cast(int) dpi.y;

        // Mark as valid
        chunks[i].isValid = true;

    }

    /// Draw onscreen parts of the texture.
    void drawAlign(FluidBackend backend, Rectangle rectangle, Color tint = color("#fff")) {

        // Draw each visible chunk
        foreach (index; visibleChunks(rectangle.start, backend.windowSize)) {

            assert(chunks[index].texture.backend !is null);
            debug assert(backend is chunks[index].texture.backend,
                .format!"Backend mismatch %s != %s"(backend, chunks[index].texture.backend));

            const start = rectangle.start + chunkPosition(index);
            const size = chunks[index].texture.viewportSize;
            const rect = Rectangle(start.tupleof, size.tupleof);

            // Assign palette
            chunks[index].palette = palette;

            backend.drawTextureAlign(chunks[index], rect, tint);

        }

    }

}

unittest {

    import std.conv;
    import fluid.label;
    import fluid.scroll;

    enum chunkSize = CompositeTexture.maxChunkSize;

    auto io = new HeadlessBackend;
    auto root = vscrollable!label(
        nullTheme.derive(
            rule!Label(
                Rule.textColor = color("#000"),
            ),
        ),
        "One\nTwo\nThree\nFour\nFive\n"
    );

    root.io = io;
    root.draw();

    // One chunk only
    assert(root.text.texture.chunks.length == 1);

    // This one chunk must have been drawn
    io.assertTexture(root.text.texture.chunks[0], Vector2(), color("#fff"));

    // Add a lot more text
    io.nextFrame;
    root.text = root.text.repeat(30).joiner.text;
    root.draw();

    const textSize = root.text._sizeDots;

    // Make sure assumptions for this test are sound:
    assert(textSize.y > chunkSize * 2, "Generated text must span at least three chunks");
    assert(io.windowSize.y < chunkSize, "Window size must be smaller than chunk size");

    // This time, there should be more chunks
    assert(root.text.texture.chunks.length >= 3);

    // Only the first one would be drawn, however
    io.assertTexture(root.text.texture.chunks[0], Vector2(), color("#fff"));
    assert(io.textures.walkLength == 1);

    // And, only the first one should be generated
    assert(root.text.texture.chunks[0].isValid);
    assert(root.text.texture.chunks[1 .. $].all!((ref a) => !a.isValid));

    // Scroll just enough so that both chunks should be on screen
    io.nextFrame;
    root.scroll = chunkSize - 1;
    root.draw();

    // First two chunks must have been generated and drawn
    assert(root.text.texture.chunks[0 .. 2].all!((ref a) => a.isValid));
    assert(root.text.texture.chunks[2 .. $].all!((ref a) => !a.isValid));

    io.assertTexture(root.text.texture.chunks[0], Vector2(0, -root.scroll), color("#fff"));
    io.assertTexture(root.text.texture.chunks[1], Vector2(0, -root.scroll + chunkSize), color("#fff"));
    assert(io.textures.walkLength == 2);

    // Skip to third chunk, force regeneration
    io.nextFrame;
    root.scroll = 2 * chunkSize - 1;
    root.updateSize();
    root.draw();

    // Because of the resize, the first chunk must have been destroyed
    assert(root.text.texture.chunks[0 .. 1].all!((ref a) => !a.isValid));
    assert(root.text.texture.chunks[1 .. 3].all!((ref a) => a.isValid));
    assert(root.text.texture.chunks[3 .. $].all!((ref a) => !a.isValid));

    io.assertTexture(root.text.texture.chunks[1], Vector2(0, -root.scroll + chunkSize), color("#fff"));
    io.assertTexture(root.text.texture.chunks[2], Vector2(0, -root.scroll + chunkSize*2), color("#fff"));
    assert(io.textures.walkLength == 2);

}

unittest {

    import std.file;
    import fluid.text_input;

    auto root = textInput();
    root.draw();
    root.io.clipboard = readText(__FILE_FULL_PATH__);
    root.paste();
    root.draw();

}
