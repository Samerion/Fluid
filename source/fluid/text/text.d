module fluid.text.text;

import std.uni;
import std.math;
import std.range;
import std.string;
import std.algorithm;

import fluid.node;
import fluid.style;
import fluid.utils;
import fluid.backend;

import fluid.text.rope;
import fluid.text.ruler;
import fluid.text.cache;
import fluid.text.typeface;
import fluid.text.composite_texture;


@safe:


/// Create a Text struct with given range as a text layer map.
StyledText!StyleRange mapText(StyleRange)(Node node, const char[] text, StyleRange range) {

    return typeof(return)(node, text, range);

}

alias Text = StyledText!();

/// Draws text: handles updates, formatting and styling.
struct StyledText(StyleRange = TextStyleSlice[]) {

    static assert(isForwardRange!StyleRange,
        "StyleRange must be a valid forward range of TextStyleSlices");
    static assert(is(ElementType!StyleRange : TextStyleSlice),
        "StyleRange must be a valid forward range of TextStyleSlices");

    /// Minimum distance between automatically created checkpoints.
    /// See_Also: `_cache`, `measure`
    private enum checkpointDistance = 128;
    static assert(checkpointDistance > CachedTextRuler.sizeof);

    public {

        /// Node owning this text struct.
        Node node;

        /// Texture generated by the struct.
        CompositeTexture texture;

        /// Range assigning slices of text to styles by index. A single text can have up to 256 different styles.
        ///
        /// Ranges should not overlap, and must be ordered by `start`. If a piece of text is not matched, it is assumed
        /// to belong to style 0.
        StyleRange styleMap;

        /// If true, enables optimizations for frequently edited text.
        bool hasFastEdits;

        /// Indent width, in pixels.
        float indentWidth = 32;

    }

    package {

        /// Last used DPI.
        Vector2 _dpi;

        /// Last used font size.
        float _fontSize;

        /// Cache of all measured text segments.
        TextRulerCache _cache;

        /// Underlying text.
        Rope _value;

        /// Text bounding box size, in dots.
        Vector2 _sizeDots;

        /// If true, text will be wrapped if it doesn't fit available space.
        bool _wrap;

        /// Start and end of the update range; area of the text that was updated since the last resize and has to be
        /// measured again. Both are inclusive.
        size_t _updateRangeStart, _updateRangeEnd;

    }

    alias minSize = size;
    alias value this;

    static if (is(StyleRange == TextStyleSlice[]))
    this(Node node, Rope text) {

        this.node = node;
        opAssign(text);

    }

    this(Node node, Rope text, StyleRange styleMap) {

        this.styleMap = styleMap;
        this.node = node;
        opAssign(text);

    }

    static if (is(StyleRange == TextStyleSlice[]))
    this(Node node, const(char)[] text) {

        this.node = node;
        opAssign(text);

    }

    this(Node node, const(char)[] text, StyleRange styleMap) {

        this.styleMap = styleMap;
        this.node = node;
        opAssign(text);

    }

    /// Copy the text, clear ownership and texture.
    this(StyledText text) const {

        this.node = null;
        this._value = text.value;
        this.styleMap = text.styleMap.save;

    }

    inout(FluidBackend) backend() inout {

        if (node.tree)
            return node.tree.backend;
        else
            return null;

    }

    /// Get or the value rendered by this text.
    /// 
    /// If more text is rendered, partial changes should be done through `replace`.
    ///
    /// Params:
    ///     newValue = Set a new value for this text.
    /// Returns: The value.
    ref inout(Rope) value() inout {

        return _value;

    }

    /// ditto
    Rope value(Rope newValue) {

        replace(0, _value.length, newValue);
        return _value;

    }

    /// ditto
    Rope value(const char[] newValue) {

        return value(Rope(newValue));

    }

    /// Clear cache and reload all text.
    void reload() {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        auto width = _cache.startRuler.lineWidth;

        clearCache(typeface, width);

    }

    /// Queue reloading text in range. If the range changes length, specify both oldHigh and newHigh.
    ///
    /// This does NOT perform the action immediately. It updates text intervals in the cache, and marks the 
    /// area that needs to be remeasurement. Positions will update on the next resize, which is triggered as this 
    /// function is called.
    ///
    /// Params:
    ///     start       = Interval from text to start of both ranges, inclusive.
    ///     oldInterval = Interval covering the now deleted text.
    ///     newInterval = Interval covering the newly inserted text. If omitted, it is assumed to be the same and
    ///         the interval size does not change.
    void reload(TextInterval start, TextInterval oldInterval, TextInterval newInterval) {

        const newEnd = start + newInterval;

        node.updateSize();

        // Make sure each of the previously added TextRuler cache checkpoints point to the same characters, still.
        // It is likely some of their positions have stayed the same, at least partially, which can save us a lot of
        // time if we reuse them.
        _cache.updateInterval(start, oldInterval, newInterval);

        // No update range is set, replace it
        if (_updateRangeStart == _updateRangeEnd) {

            _updateRangeStart = start.length;
            _updateRangeEnd   = newEnd.length;
    
        }

        // Update boundaries of the existing update range
        else {

            if (start.length < _updateRangeStart)
                _updateRangeStart = start.length;

            if (newEnd.length > _updateRangeEnd)
                _updateRangeEnd = newEnd.length;

        }
        
    }

    /// Replace value at a given range with a new value. This is the main, and fastest way to operate on TextInput text.
    ///
    /// Params:
    ///     start  = Start index, inclusive; First index to delete.
    ///     end    = End index, exclusive; First index after the newly inserted fragment.
    ///     value  = Value to insert.
    void replace(size_t start, size_t end, Rope value) {

        // Ignore if there's no change
        if (start == end && value.length == 0) return;

        const startInterval = positionOf(start);
        const oldInterval   = positionOf(end)
            .dropHead(startInterval);

        _value = _value.replace(start, end, value);

        const newInterval = TextInterval(value);
        
        reload(startInterval, oldInterval, newInterval);

    }

    /// ditto
    void replace(size_t start, size_t end, const(char)[] value) {

        replace(start, end, Rope(value));

    }

    /// Returns: 
    ///     Interval between the start of text and the character at given index. This can be used to determine the line
    ///     and column number of the given character.
    /// Params:
    ///     index = Index to search for.
    TextInterval positionOf(size_t index) {

        // Find a suitable point to start search at
        const range = query(&_cache, index);
        const point = range.front.point;

        const start = point.length;
        const end   = index;

        return point + TextInterval(value[start .. end]);

    }

    Rope opAssign(Rope text) {

        // Identical; no change is to be made
        if (text is value) return text;

        // Request an update
        node.updateSize();
        return value = text;


    }

    const(char)[] opAssign(const(char)[] text) {

        // Ignore if there's no change to be made
        if (text == value) return text;

        // Request update otherwise
        value = text;
        return text;

    }

    string opIndexAssign(string value, size_t[2] index) {

        replace(index[0], index[1], Rope(value));
        return value;

    }

    Rope opIndexAssign(Rope value, size_t[2] index) {

        replace(index[0], index[1], value);
        return value;

    }

    char opIndex(size_t index) const nothrow {

        return value[index];

    }

    Rope opIndex(size_t[2] index) const nothrow {

        return value[index];
        
    }

    size_t[2] opSlice(size_t dim : 0)(size_t i, size_t j) const nothrow {

        return [i, j];

    }

    size_t opDollar() const nothrow {

        return value.length;

    }
    
    void opOpAssign(string operator : "~")(const(char)[] text) {

        replace(value.length, value.length, text);

    }

    void opOpAssign(string operator : "~")(Rope text) {

        replace(value.length, value.length, text);

    }

    /// Get the size of the text.
    Vector2 size() const {

        const scale = backend.hidpiScale;

        return Vector2(
            _sizeDots.x / scale.x,
            _sizeDots.y / scale.y,
        );

    }

    alias minSize = size;

    /// Measure and set the bounding box for this text.
    void resize() {

        resize!keepWords(Vector2(), false);

    }

    /// Set new bounding box for the text; wrap the text if it doesn't fit in boundaries.
    /// Params:
    ///     splitter = Function to use to split the text. Currently unsupported.
    ///     space    = Boundaries to fit the text in.
    ///     wrap     = Wrap text, on by default.
    void resize(alias splitter = Typeface.defaultWordChunks)(Vector2 space, bool wrap = true)
    in (node, "Text was not initialized; `node` was not set.")
    do {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const dpi = backend.dpi;
        const scale = backend.hidpiScale;

        // Apply DPI
        style.setDPI(dpi);
        typeface.indentWidth = cast(int) (indentWidth * scale.x);
        space.x *= scale.x;
        space.y *= scale.y;

        /// Minimum pixel change that counts
        measure!splitter(space, wrap);
        clearTextures();

    }

    /// Returns: Number of pixels in both directions that may make a notable visual difference.
    private Vector2 epsilon() const {

        return 96 / 4 / backend.dpi;

    }

    /// Test for changes to text properties: typeface, DPI, font size, box width and wrapping. 
    /// Returns: True if the cache should be purged. 
    private bool shouldCacheReset(Vector2 space, bool wrap) {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;

        const dpi = backend.dpi;
        const firstRuler = _cache.startRuler;
        const widthChanged = wrap && abs(space.x - firstRuler.lineWidth) >= epsilon.x;

        return widthChanged
            || typeface !is firstRuler.typeface
            || abs(dpi.x - _dpi.x) >= epsilon.x
            || abs(dpi.y - _dpi.y) >= epsilon.y
            || abs(style.fontSize - _fontSize) >= epsilon.y 
            || wrap != _wrap;

    }

    /// Clear the cache.
    private void clearCache(Typeface typeface, float lineWidth)
    in (typeface)
    do {

        auto ruler = TextRuler(typeface, lineWidth);
        ruler.startLine();
        _cache = TextRulerCache(ruler);
        _dpi = backend 
            ? backend.dpi
            : Vector2();
        _updateRangeStart = 0;
        _updateRangeEnd = value.length;

    }

    /// Measure text size in the update region and update `_sizeDots` to the bounding box of this text. Size is 
    /// expressed in terms of screen dots.
    /// 
    /// The update region is a single continuous area in the `value` that has been written since the last `measure` 
    /// call. Any changed piece of text will be placed in the update region to be picked up and measured by this 
    /// function. Because this function cannot distinguish between modifications made in multiple different spots, 
    /// unmodified text between two edited spots of text will be included in the region as well. This function
    /// resets the update region once it is finished.
    ///
    /// While measuring text in the update region, "checkpoints" with measurement data are created and written to 
    /// `_cache`. This makes it possible to find the position of a character in the text afterwards without having to 
    /// remeasure the entire text. Furthermore, it's used to make subsequent measurements faster as area before the 
    /// update region can be skipped, and lines after can be just offset without measuring them again.
    /// 
    /// Params:
    ///     splitter = Function to use to split words.
    ///     space   = Limit for the space of the region the text shouldn't cross, in dots.
    ///     wrap    = If true, text should be limited by a bounding box.
    private void measure(alias splitter = Typeface.defaultWordChunks)(Vector2 space, bool wrap)
    out (; isMeasured)
    do {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const epsilon = this.epsilon;

        // Unset space if wrapping is disabled
        if (!wrap) space = Vector2(float.nan, float.nan);

        // Reset the cache if text properties changed
        if (shouldCacheReset(space, wrap)) {
            clearCache(typeface, space.x);
            _wrap = wrap;
        }

        // Nothing to update
        if (_updateRangeStart == _updateRangeEnd && value != "") return;

        // Find the first beacon to update
        scope rulers = query(&_cache, _updateRangeStart);
        auto ruler = rulers.front;
        bool started;
        float yOffset = 0;
        rulers.popFront;

        assert(!wrap || abs(ruler.lineWidth - space.x) < epsilon.x,
            format!"Line width mismatch: ruler(%s), space(%s)"(ruler.lineWidth, space.x));

        const start = ruler.point.length;
        size_t lastCheckpoint = start;

        // Split on lines
        foreach (index, line; Typeface.lineSplitterIndex(value[start .. $])) {

            if (started) {
                ruler.startLine();
                ruler.point.line++;
                ruler.point.column = 0;
            }
            else started = true;

            // Split on words
            foreach (word, penPosition; Typeface.eachWord!splitter(ruler, line, wrap)) {

                const startIndex = index;

                index += word.length;

                // Keep the ruler's location in sync
                ruler.point.length = start + index;
                ruler.point.column += word.length;

                // If we're in the update range (iterating through newly added text), we need to periodically write 
                // rulers to cache 
                if (startIndex <= _updateRangeEnd) {

                    // Delete any outdated checkpoint in the cache
                    // TODO This might not even be necessary — cache should have already purged these points
                    while (!rulers.empty && index >= rulers.front.point.length) {

                        rulers.removeFront();

                    }

                    // Regularly create a checkpoint in the cache
                    if (index >= lastCheckpoint + checkpointDistance) {

                        lastCheckpoint = index;
                        _cache.insert(ruler.point, ruler);

                    }

                }

                // We're measuring text that should already have checkpoints written to cache.
                // We just need to compare with existing checkpoints and update them if necessary.
                else if (!rulers.empty) {

                    // X position is different, override the ruler and continue measurements
                    if (abs(rulers.front.penPosition.x - ruler.penPosition.x) >= epsilon.x) {
                        rulers.front = ruler;
                        continue;
                    }

                    // Only Y position is different, stop here and save the offset 
                    else if (abs(rulers.front.penPosition.y - ruler.penPosition.y) >= epsilon.y) {
                        yOffset = ruler.penPosition.y - rulers.front.penPosition.y;
                        rulers.front = ruler;
                    }

                    break;

                }

            }

        }

        // The remaining lines have not changes, so we can just apply the same offset we did on the last line
        if (yOffset)
        for (; !rulers.empty; rulers.popFront) {
            ruler = rulers.front;
            ruler.penPosition.y += yOffset;
            rulers.front = rulers.front;
        }

        // Now that the cache is built, we can find out what the position of the last character is so we can get 
        // the bounding box
        ruler = requireRulerAt(value.length);
        _sizeDots = ruler.textSize;
        _updateRangeStart = 0;
        _updateRangeEnd = 0;

    }

    bool isMeasured() const {

        return _cache !is _cache.init
            && _updateRangeStart == _updateRangeEnd;

    }

    /// `rulerAt` gets measurement data for the given text position. This data can be used to map characters to their 
    /// screen position or find their size. 
    ///
    /// `requireRulerAt` will do the same, but it will also cache the result value for faster subsequent lookup. The
    /// regular `rulerAt` overload is recommended for most cases.
    ///
    /// For this function to work, measurement data must be available; make sure `resize` was called beforehand. This
    /// will be checked at runtime.
    ///
    /// Returns: 
    ///     Text ruler with text measurement data from the start of the text to the given character, not including 
    ///     queried character.
    /// Params:
    ///     index = Index of the requested character.
    CachedTextRuler rulerAt(size_t index, bool preferNextLine = false)
    in (_cache !is _cache.init, "Text was not measured. Call `resize()` first.")
    do {

        // TODO Custom text breaking

        /// Returns the longest unbreakable substring of the given value.
        Rope unbreakableChars(Rope value) {

            // Split on lines
            auto lines = Typeface.lineSplitter(value);
            if (lines.empty) return Rope.init;

            // Split on words
            auto chunks = Typeface.defaultWordChunks(lines.front);
            if (chunks.empty) return Rope.init;

            // Return empty string if the result starts with whitespace
            if (chunks.front.byDchar.front.isWhite) return value.init;

            // Return first word only
            return chunks.front;

        }

        alias splitter = Typeface.defaultWordChunks;

        auto ruler = query(&_cache, index).front;
        bool started;

        assert(ruler.typeface !is null);

        // Too much to calculate at once! Trigger a resize first
        if (index - ruler.point.length >= checkpointDistance) {

            // Y position does not matter at this moment
            resize(Vector2(ruler.lineWidth, 0), _wrap);

            // Query again
            ruler = query(&_cache, index).front;

        }

        // Check if the caret follows unbreakable characters
        // If the caret is surrounded by unbreakable characters, include them in the output to make sure the
        // word is wrapped correctly
        const unbreakablePrefix = unbreakableChars(
            value[0 .. index].wordBack(true)
        );
        const unbreakableSuffix = unbreakablePrefix.empty && !preferNextLine
            ? Rope.init
            : unbreakableChars(value[index .. $]);

        const start = ruler.point.length;
        const end   = index + unbreakableSuffix.length;

        // Split on lines
        foreach (line; Typeface.lineSplitter!(Yes.keepTerminator)(value[start .. end])) {

            if (started) {
                ruler.startLine();
                ruler.point.line++;
                ruler.point.column = 0;
            }
            else started = true;

            ruler.point.length += line.length;
            ruler.point.column += line.length;

            // Split on words, but don't do anything
            foreach (word, penPosition; Typeface.eachWord!splitter(ruler, line, _wrap)) { }

        }

        // If the position is mid-word, we have to remove the suffix
        // TODO textSize might be incorrect here
        ruler.penPosition.x -= ruler.typeface.measure(unbreakableSuffix[]).x;

        return ruler;

    }

    CachedTextRuler requireRulerAt(size_t index) {

        auto ruler = rulerAt(index);
        _cache.insert(ruler.point, ruler);
        return ruler;

    }

    /// Reset the texture, destroying it and replacing it with a blank.
    void clearTextures() {

        texture.format = Image.Format.palettedAlpha;
        texture.resize(_sizeDots, hasFastEdits);

    }

    /// Generate the textures, if not already generated.
    ///
    /// Params:
    ///     chunks = Indices of chunks that need to be regenerated.
    ///     position = Position of the text; If given, only on-screen chunks will be generated.
    void generate(Vector2 position) {

        generate(texture.visibleChunks(position, backend.windowSize));

    }

    /// ditto
    void generate(R)(R chunks) @trusted {

        // Empty, nothing to do
        if (chunks.empty) return;

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const dpi = backend.dpi;
        const scale = backend.hidpiScale;

        // Apply sizing settings
        style.setDPI(dpi);
        typeface.indentWidth = cast(int) (indentWidth * scale.x);

        // Ignore chunks which have already been generated
        auto newChunks = chunks
            .filter!(index => !texture.chunks[index].isValid);

        // No chunks to render, stop here
        if (newChunks.empty) return;

        // Clear the chunks
        foreach (chunkIndex; newChunks) {

            texture.clearImage(chunkIndex);

        }

        auto ruler = TextRuler(typeface, _sizeDots.x);

        // Copy the layer range, make it infinite
        auto styleMap = this.styleMap.save.chain(TextStyleSlice.init.repeat);

        // Run through the text
        foreach (index, line; Typeface.lineSplitterIndex(value)) {

            ruler.startLine();

            // Split on words
            // TODO use the splitter provided when resizing
            foreach (word, penPosition; Typeface.eachWord(ruler, line, _wrap)) {

                const wordEnd = index + word.length;

                // Split the word based on the layer map
                while (index != wordEnd) {

                    const remaining = wordEnd - index;
                    auto wordFragment = word[$ - remaining .. $];
                    auto range = styleMap.front;

                    // Advance the layer map if exceeded the end
                    if (index >= range.end) {
                        styleMap.popFront;
                        continue;
                    }

                    ubyte styleIndex;

                    // Match found here
                    if (index >= range.start) {

                        // Find the end of the range
                        const end = min(wordEnd, range.end) - index;
                        wordFragment = wordFragment[0 .. end];
                        styleIndex = range.styleIndex;

                    }

                    // Match found later
                    else if (range.start < wordEnd) {

                        wordFragment = wordFragment[0 .. range.start - index];

                    }

                    const currentPenPosition = penPosition;

                    // Draw the fragment to selected chunks
                    foreach (chunkIndex; newChunks) {

                        const chunkRect = texture.chunkRectangle(chunkIndex);

                        // Ignore chunks this word is not in the bounds of
                        const relevant = chunkRect.contains(ruler.caret(currentPenPosition).start)
                            || chunkRect.contains(ruler.caret.end);

                        if (!relevant) continue;

                        // Get pen position relative to this chunk
                        auto relativePenPosition = currentPenPosition - chunkRect.start;

                        // Note: relativePenPosition is passed by ref
                        auto image = texture.chunks[chunkIndex].image;
                        typeface.drawLine(image, relativePenPosition, wordFragment, styleIndex);

                        // Update the pen position; Result of this should be the same for each chunk
                        penPosition = relativePenPosition + chunkRect.start;

                    }

                    // Update the index
                    index += wordFragment.length;

                }

            }

        }

        // Load the updated chunks
        foreach (chunkIndex; newChunks) {

            texture.upload(backend, chunkIndex, dpi);

        }

    }

    /// Draw the text.
    void draw(const Style style, Vector2 position) {

        scope const Style[1] styles = [style];

        draw(styles, position);

    }

    /// ditto
    void draw(scope const Style[] styles, Vector2 position)
    in (styles.length >= 1, "At least one style must be passed to draw(Style[], Vector2)")
    do {

        import std.math;
        import fluid.utils;

        const rectangle = Rectangle(position.tupleof, size.tupleof);
        const screen = Rectangle(0, 0, node.io.windowSize.tupleof);

        // Ignore if offscreen
        if (!overlap(rectangle, screen)) return;

        // Regenerate visible textures
        generate(position);

        // Make space in the texture's palette
        if (texture.palette.length != styles.length)
            texture.palette.length = styles.length;

        // Fill it with text colors of each of the styles
        styles.map!"a.textColor".copy(texture.palette);

        // Draw the texture if present
        texture.drawAlign(backend, rectangle);

    }

    /// ditto
    deprecated("Use draw(Style, Vector2) instead. Hint: Use fluid.utils.start(Rectangle) to get the position vector.")
    void draw(const Style style, Rectangle rectangle) {

        // Should this "crop" the result?

        draw(style, Vector2(rectangle.x, rectangle.y));

    }

    string toString() const {

        import std.conv : to;

        return _value.to!string;

    }

}

struct TextStyleSlice {

    /// Start and end of this slice. Start is inclusive, end is exclusive. The range may exceed text boundaries.
    auto start = size_t.max;

    /// ditto
    auto end = size_t.max;

    invariant(start <= end);

    /// Index of the style to be assigned to the text covered by this slice.
    ubyte styleIndex;

    ptrdiff_t opCmp(const TextStyleSlice that) const {

        return cast(ptrdiff_t) this.start - cast(ptrdiff_t) that.start;

    }

    /// Apply some offset to the slice.
    TextStyleSlice offset(int offset) const {

        return TextStyleSlice(start + offset, end + offset, styleIndex);

    }

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();
    auto text = Text(root, "Hello, green world!");

    // Set colors for each part
    Style[4] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");
    styles[2].textColor = color("#55b9ff");
    styles[3].textColor = color("#0058f1");

    // Define regions
    text.styleMap = [
        TextStyleSlice(7, 12, 1),   // green
        TextStyleSlice(13, 14, 2),  // w
        TextStyleSlice(14, 15, 3),  // o
        TextStyleSlice(15, 16, 2),  // r
        TextStyleSlice(16, 17, 3),  // l
        TextStyleSlice(17, 18, 2),  // d
    ];

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize();
    text.draw(styles, Vector2(0, 0));

    // Make sure the texture was drawn with the correct color
    io.assertTexture(text.texture.chunks[0], Vector2(), color("#fff"));

    foreach (i; 0..4) {

        assert(text.texture.chunks[0].palette[i] == styles[i].textColor);
        assert(text.texture.palette[i] == styles[i].textColor);

    }

    // TODO Is there a way to reliably test if the result was drawn properly? Sampling specific pixels maybe?

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto styleMap = recurrence!"a[n-1] + 1"(0)
        .map!(a => TextStyleSlice(a, a+1, cast(ubyte) (a % 2)));

    auto text = mapText(root, "Hello, World!", styleMap);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(50, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto styleMap = [
        TextStyleSlice(2, 11, 1),
    ];

    auto text = mapText(root, "Hello, World!", styleMap);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(60, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    Style[2] styles;
    auto root = vspace();
    auto styleMap = [
        TextStyleSlice(0, 0, 1),
    ];
    auto text = mapText(root, "Hello, World!", styleMap);

    root.draw();
    text.resize();
    text.draw(styles, Vector2(0, 0));

}

/// `wordFront` and `wordBack` get the word at the beginning or end of given string, respectively.
///
/// A word is a streak of consecutive characters — non-whitespace, either all alphanumeric or all not — followed by any
/// number of whitespace.
///
/// Params:
///     text = Text to scan for the word.
///     excludeWhite = If true, whitespace will not be included in the word.
T wordFront(T)(T text, bool excludeWhite = false) {

    import std.utf : codeLength;

    size_t length;

    T result() { return text[0..length]; }
    T remaining() { return text[length..$]; }

    while (remaining != "") {

        // Get the first character
        const lastChar = remaining.decodeFrontStatic;

        // Exclude white characters if enabled
        if (excludeWhite && lastChar.isWhite) break;

        length += lastChar.codeLength!(typeof(text[0]));

        // Stop if empty
        if (remaining == "") break;

        const nextChar = remaining.decodeFrontStatic;

        // Stop if the next character is a line feed
        if (nextChar.only.chomp.empty && !only(lastChar, nextChar).equal("\r\n")) break;

        // Continue if the next character is whitespace
        // Includes any case where the previous character is followed by whitespace
        else if (nextChar.isWhite) continue;

        // Stop if whitespace follows a non-white character
        else if (lastChar.isWhite) break;

        // Stop if the next character has different type
        else if (lastChar.isAlphaNum != nextChar.isAlphaNum) break;

    }

    return result;

}

/// ditto
T wordBack(T)(T text, bool excludeWhite = false) {

    import std.utf : codeLength;

    size_t length = text.length;

    T result() { return text[length..$]; }
    T remaining() { return text[0..length]; }

    while (remaining != "") {

        // Get the first character
        const lastChar = remaining.decodeBackStatic;

        // Exclude white characters if enabled
        if (excludeWhite && lastChar.isWhite) break;

        length -= lastChar.codeLength!(typeof(text[0]));

        // Stop if empty
        if (remaining == "") break;

        const nextChar = remaining.decodeBackStatic;

        // Stop if the character is a line feed
        if (lastChar.only.chomp.empty && !only(nextChar, lastChar).equal("\r\n")) break;

        // Continue if the current character is whitespace
        // Inverse to `wordFront`
        else if (lastChar.isWhite) continue;

        // Stop if whitespace follows a non-white character
        else if (nextChar.isWhite) break;

        // Stop if the next character has different type
        else if (lastChar.isAlphaNum != nextChar.isAlphaNum) break;

    }

    return result;

}

/// `std.utf.decodeFront` and `std.utf.decodeBack` variants that do not mutate the range
dchar decodeFrontStatic(T)(T range) @trusted {

    import std.utf : decodeFront;

    return range.decodeFront;

}

/// ditto
dchar decodeBackStatic(T)(T range) @trusted {

    import std.utf : decodeBack;

    return range.decodeBack;

}

unittest {

    assert("hello world!".wordFront == "hello ");
    assert("hello, world!".wordFront == "hello");
    assert("hello world!".wordBack == "!");
    assert("hello world".wordBack == "world");
    assert("hello ".wordBack == "hello ");

    assert("witaj świecie!".wordFront == "witaj ");
    assert(" świecie!".wordFront == " ");
    assert("świecie!".wordFront == "świecie");
    assert("witaj świecie!".wordBack == "!");
    assert("witaj świecie".wordBack == "świecie");
    assert("witaj ".wordBack == "witaj ");

    assert("Всем привет!".wordFront == "Всем ");
    assert("привет!".wordFront == "привет");
    assert("!".wordFront == "!");

    // dstring
    assert("Всем привет!"d.wordFront == "Всем "d);
    assert("привет!"d.wordFront == "привет"d);
    assert("!"d.wordFront == "!"d);

    assert("Всем привет!"d.wordBack == "!"d);
    assert("Всем привет"d.wordBack == "привет"d);
    assert("Всем "d.wordBack == "Всем "d);

    // Whitespace exclusion
    assert("witaj świecie!".wordFront(true) == "witaj");
    assert(" świecie!".wordFront(true) == "");
    assert("witaj świecie".wordBack(true) == "świecie");
    assert("witaj ".wordBack(true) == "");

}

unittest {

    assert("\nabc\n".wordFront == "\n");
    assert("\n  abc\n".wordFront == "\n  ");
    assert("abc\n".wordFront == "abc");
    assert("abc  \n".wordFront == "abc  ");
    assert("  \n".wordFront == "  ");
    assert("\n     abc".wordFront == "\n     ");

    assert("\nabc\n".wordBack == "\n");
    assert("\nabc".wordBack == "abc");
    assert("abc  \n".wordBack == "\n");
    assert("abc  ".wordFront == "abc  ");
    assert("\nabc\n  ".wordBack == "\n  ");
    assert("\nabc\n  a".wordBack == "a");

    assert("\r\nabc\r\n".wordFront == "\r\n");
    assert("\r\n  abc\r\n".wordFront == "\r\n  ");
    assert("abc\r\n".wordFront == "abc");
    assert("abc  \r\n".wordFront == "abc  ");
    assert("  \r\n".wordFront == "  ");
    assert("\r\n     abc".wordFront == "\r\n     ");

    assert("\r\nabc\r\n".wordBack == "\r\n");
    assert("\r\nabc".wordBack == "abc");
    assert("abc  \r\n".wordBack == "\r\n");
    assert("abc  ".wordFront == "abc  ");
    assert("\r\nabc\r\n  ".wordBack == "\r\n  ");
    assert("\r\nabc\r\n  a".wordBack == "a");

}
