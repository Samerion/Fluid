module fluid.text.text;

import std.uni;
import std.conv;
import std.math;
import std.range;
import std.string;
import std.algorithm;

import fluid.node;
import fluid.style;
import fluid.utils;
import fluid.backend;

import fluid.text.util;
import fluid.text.rope;
import fluid.text.ruler;
import fluid.text.cache;
import fluid.text.typeface;
import fluid.text.composite_texture;


@safe:


/// Create a Text struct with given range as a text layer map.
StyledText!StyleRange mapText(StyleRange)(Node node, const char[] text, StyleRange range) {

    return typeof(return)(node, text, range);

}

alias Text = StyledText!();

/// Draws text: handles updates, formatting and styling.
struct StyledText(StyleRange = TextStyleSlice[]) {

    static assert(isForwardRange!StyleRange,
        "StyleRange must be a valid forward range of TextStyleSlices");
    static assert(is(ElementType!StyleRange : TextStyleSlice),
        "StyleRange must be a valid forward range of TextStyleSlices");

    /// Minimum distance between automatically created checkpoints.
    /// See_Also: `_cache`, `measure`
    private enum checkpointDistance = 256;
    static assert(checkpointDistance > CachedTextRuler.sizeof);

    public {

        /// Node owning this text struct.
        Node node;

        /// Texture generated by the struct.
        CompositeTexture texture;

        /// Range assigning slices of text to styles by index. A single text can have up to 256 different styles.
        ///
        /// Ranges should not overlap, and must be ordered by `start`. If a piece of text is not matched, it is assumed
        /// to belong to style 0.
        StyleRange styleMap;

        /// If true, enables optimizations for frequently edited text.
        bool hasFastEdits;

        /// Indent width, in pixels.
        float indentWidth = 32;

    }

    package {

        /// Last used DPI.
        Vector2 _dpi;

        /// Last used font size.
        float _fontSize;

        /// Cache of all measured text segments.
        TextRulerCache _cache;

        /// Underlying text.
        Rope _value;

        /// Text bounding box size, in dots.
        Vector2 _sizeDots;

        /// If true, text will be wrapped if it doesn't fit available space.
        bool _wrap;

        /// Start and end of the update range; area of the text that was updated since the last resize and has to be
        /// measured again. Both are inclusive.
        size_t _updateRangeStart, _updateRangeEnd;

    }

    alias minSize = size;
    alias value this;

    static if (is(StyleRange == TextStyleSlice[]))
    this(Node node, Rope text) {

        this.node = node;
        opAssign(text);

    }

    this(Node node, Rope text, StyleRange styleMap) {

        this.styleMap = styleMap;
        this.node = node;
        opAssign(text);

    }

    static if (is(StyleRange == TextStyleSlice[]))
    this(Node node, const(char)[] text) {

        this.node = node;
        opAssign(text);

    }

    this(Node node, const(char)[] text, StyleRange styleMap) {

        this.styleMap = styleMap;
        this.node = node;
        opAssign(text);

    }

    /// Copy the text, clear ownership and texture.
    this(StyledText text) const {

        this.node = null;
        this._value = text.value;
        this.styleMap = text.styleMap.save;

    }

    inout(FluidBackend) backend() inout {

        if (node.tree)
            return node.tree.backend;
        else
            return null;

    }

    /// Get or the value rendered by this text.
    /// 
    /// If more text is rendered, partial changes should be done through `replace`.
    ///
    /// Params:
    ///     newValue = Set a new value for this text.
    /// Returns: The value.
    ref inout(Rope) value() inout {

        return _value;

    }

    /// ditto
    Rope value(Rope newValue) {

        replace(0, _value.length, newValue);
        return _value;

    }

    /// ditto
    Rope value(const char[] newValue) {

        return value(Rope(newValue));

    }

    /// Clear cache and reload all text.
    void reload() {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        auto width = _cache.startRuler.lineWidth;

        clearCache(typeface, width);

    }

    /// Queue reloading text in range. If the range changes length, specify both oldHigh and newHigh.
    ///
    /// This does NOT perform the action immediately. It updates text intervals in the cache, and marks the 
    /// area that needs to be remeasurement. Positions will update on the next resize, which is triggered as this 
    /// function is called.
    ///
    /// Params:
    ///     start       = Interval from text to start of both ranges, inclusive.
    ///     oldInterval = Interval covering the now deleted text.
    ///     newInterval = Interval covering the newly inserted text. If omitted, it is assumed to be the same and
    ///         the interval size does not change.
    void reload(TextInterval start, TextInterval oldInterval, TextInterval newInterval) {

        const newEnd = start + newInterval;

        node.updateSize();

        // Make sure each of the previously added TextRuler cache checkpoints point to the same characters, still.
        // It is likely some of their positions have stayed the same, at least partially, which can save us a lot of
        // time if we reuse them.
        _cache.updateInterval(start, oldInterval, newInterval);

        // No update range is set, replace it
        if (_updateRangeStart == _updateRangeEnd) {

            _updateRangeStart = start.length;
            _updateRangeEnd   = newEnd.length;
    
        }

        // Update boundaries of the existing update range
        else {

            if (start.length < _updateRangeStart)
                _updateRangeStart = start.length;

            if (newEnd.length > _updateRangeEnd)
                _updateRangeEnd = newEnd.length;

        }
        
    }

    /// Replace value at a given range with a new value. This is the main, and fastest way to operate on TextInput text.
    ///
    /// Params:
    ///     start  = Start index, inclusive; First index to delete.
    ///     end    = End index, exclusive; First index after the newly inserted fragment.
    ///     value  = Value to insert.
    void replace(size_t start, size_t end, Rope value) {

        // Ignore if there's no change
        if (start == end && value.length == 0) return;

        const startInterval = positionOf(start);
        const oldInterval   = positionOf(end)
            .dropHead(startInterval);

        _value = _value.replace(start, end, value);

        const newInterval = TextInterval(value);
        
        reload(startInterval, oldInterval, newInterval);

    }

    /// ditto
    void replace(size_t start, size_t end, const(char)[] value) {

        replace(start, end, Rope(value));

    }

    /// Returns: 
    ///     Interval between the start of text and the character at given index. This can be used to determine the line
    ///     and column number of the given character.
    /// Params:
    ///     index = Index to search for.
    TextInterval positionOf(size_t index) {

        // Find a suitable point to start search at
        const range = freshCacheQuery(index);
        const point = range.front.point;

        const start = point.length;
        const end   = index;

        return point + TextInterval(value[start .. end]);

    }

    /// Query the cache by index, ensuring the cache is fresh.
    ///
    /// If the cache was not generated recently, checkpoints may be absent or very rare, making it very slow to perform
    /// multiple cache queries. This function will detect this situation and refresh the cache as needed.
    ///
    /// Params:
    ///     index = Index to query.
    /// Returns:
    ///     The `query` result as-is, using recent data.
    private auto freshCacheQuery(size_t index) {

        auto range = query(&_cache, index);

        assert(index >= range.front.point.length);

        // The result is good enough, return it
        if (index - range.front.point.length <= checkpointDistance) {
            return range.move;
        }

        // Cache is stale, measure again
        resize(Vector2(range.front.lineWidth, 0), _wrap);
        return query(&_cache, index);

    }

    Rope opAssign(Rope text) {

        // Identical; no change is to be made
        if (text is value) return text;

        // Request an update
        node.updateSize();
        return value = text;


    }

    const(char)[] opAssign(const(char)[] text) {

        // Ignore if there's no change to be made
        if (text == value) return text;

        // Request update otherwise
        value = text;
        return text;

    }

    string opIndexAssign(string value, size_t[2] index) {

        replace(index[0], index[1], Rope(value));
        return value;

    }

    Rope opIndexAssign(Rope value, size_t[2] index) {

        replace(index[0], index[1], value);
        return value;

    }

    char opIndex(size_t index) const nothrow {

        return value[index];

    }

    Rope opIndex(size_t[2] index) const nothrow {

        return value[index];
        
    }

    size_t[2] opSlice(size_t dim : 0)(size_t i, size_t j) const nothrow {

        return [i, j];

    }

    size_t opDollar() const nothrow {

        return value.length;

    }
    
    void opOpAssign(string operator : "~")(const(char)[] text) {

        replace(value.length, value.length, text);

    }

    void opOpAssign(string operator : "~")(Rope text) {

        replace(value.length, value.length, text);

    }

    /// Get the size of the text.
    Vector2 size() const {

        const scale = backend.hidpiScale;

        return Vector2(
            _sizeDots.x / scale.x,
            _sizeDots.y / scale.y,
        );

    }

    alias minSize = size;

    /// Measure and set the bounding box for this text.
    void resize() {

        resize!keepWords(Vector2(), false);

    }

    /// Set new bounding box for the text; wrap the text if it doesn't fit in boundaries.
    /// Params:
    ///     splitter = Function to use to split the text. Currently unsupported.
    ///     space    = Boundaries to fit the text in.
    ///     wrap     = Wrap text, on by default.
    void resize(alias splitter = Typeface.defaultWordChunks)(Vector2 space, bool wrap = true)
    in (node, "Text was not initialized; `node` was not set.")
    do {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const dpi = backend.dpi;
        const scale = backend.hidpiScale;

        // Apply DPI
        style.setDPI(dpi);
        typeface.indentWidth = cast(int) (indentWidth * scale.x);
        space.x *= scale.x;
        space.y *= scale.y;

        /// Minimum pixel change that counts
        measure!splitter(space, wrap);
        clearTextures();

    }

    /// Returns: Number of pixels in both directions that may make a notable visual difference.
    private Vector2 epsilon() const {

        return 96 / 4 / backend.dpi;

    }

    /// Test for changes to text properties: typeface, DPI, font size, box width and wrapping. 
    /// Returns: True if the cache should be purged. 
    private bool shouldCacheReset(Vector2 space, bool wrap) {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;

        const dpi = backend.dpi;
        const firstRuler = _cache.startRuler;
        const widthChanged = wrap && abs(space.x - firstRuler.lineWidth) >= epsilon.x;

        return widthChanged
            || typeface !is firstRuler.typeface
            || abs(dpi.x - _dpi.x) >= epsilon.x
            || abs(dpi.y - _dpi.y) >= epsilon.y
            || abs(style.fontSize - _fontSize) >= epsilon.y 
            || wrap != _wrap;

    }

    /// Clear the cache.
    private void clearCache(Typeface typeface, float lineWidth)
    in (typeface)
    do {

        auto ruler = TextRuler(typeface, lineWidth);
        ruler.startLine();
        _cache = TextRulerCache(ruler);
        _dpi = backend 
            ? backend.dpi
            : Vector2();
        _updateRangeStart = 0;
        _updateRangeEnd = value.length;

    }

    /// Measure text size in the update region and update `_sizeDots` to the bounding box of this text. Size is 
    /// expressed in terms of screen dots.
    /// 
    /// The update region is a single continuous area in the `value` that has been written since the last `measure` 
    /// call. Any changed piece of text will be placed in the update region to be picked up and measured by this 
    /// function. Because this function cannot distinguish between modifications made in multiple different spots, 
    /// unmodified text between two edited spots of text will be included in the region as well. This function
    /// resets the update region once it is finished.
    ///
    /// While measuring text in the update region, "checkpoints" with measurement data are created and written to 
    /// `_cache`. This makes it possible to find the position of a character in the text afterwards without having to 
    /// remeasure the entire text. Furthermore, it's used to make subsequent measurements faster as area before the 
    /// update region can be skipped, and lines after can be just offset without measuring them again.
    /// 
    /// Params:
    ///     splitter = Function to use to split words.
    ///     space   = Limit for the space of the region the text shouldn't cross, in dots.
    ///     wrap    = If true, text should be limited by a bounding box.
    private void measure(alias splitter = Typeface.defaultWordChunks)(Vector2 space, bool wrap)
    out (; isMeasured)
    do {

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const epsilon = this.epsilon;

        // Unset space if wrapping is disabled
        if (!wrap) space = Vector2(float.nan, float.nan);

        // Reset the cache if text properties changed
        if (shouldCacheReset(space, wrap)) {
            clearCache(typeface, space.x);
            _wrap = wrap;
        }

        // Nothing to update
        if (_updateRangeStart == _updateRangeEnd && value != "") return;

        // Find the first beacon to update
        scope rulers = query(&_cache, _updateRangeStart);
        auto ruler = rulers.front;
        bool started;
        float yOffset = 0;
        rulers.popFront();

        assert(!wrap || abs(ruler.lineWidth - space.x) < epsilon.x,
            format!"Line width mismatch: ruler(%s), space(%s)"(ruler.lineWidth, space.x));

        const start = ruler.point.length;
        size_t lastCheckpoint = start;

        // Split on lines
        lines: foreach (line; value[start .. $].byLine) {

            auto index = start + line.index;

            if (started) {
                ruler.startLine();
                ruler.point.line++;
                ruler.point.column = 0;
            }
            else started = true;

            // Split on words
            foreach (word, penPosition; Typeface.eachWord!splitter(ruler, line, wrap)) {

                const startIndex = index;

                index += word.length;

                // Keep the ruler's location in sync
                ruler.point.length = index;
                ruler.point.column += word.length;

                // If we're in the update range (iterating through newly added text), we need to periodically write 
                // rulers to cache 
                if (startIndex < _updateRangeEnd) {

                    // Delete any outdated checkpoint in the cache
                    // TODO This might not even be necessary — cache should have already purged these points
                    while (!rulers.empty && index >= rulers.front.point.length) {

                        rulers.removeFront();

                    }

                    // Regularly create a checkpoint in the cache
                    if (index >= lastCheckpoint + checkpointDistance) {

                        lastCheckpoint = index;
                        _cache.insert(ruler.point, ruler);
                        () @trusted {
                            // Inferred @safe on newer compilers, but @system on LDC 1.28
                            rulers = query(&_cache, index);
                        }();
                        assert(rulers.front == ruler);
                        rulers.popFront();

                    }

                }

                // We're measuring text that should already have checkpoints written to cache.
                // We just need to compare with existing checkpoints and update them if necessary.
                else while (!rulers.empty && index >= rulers.front.point.length) {

                    // Checkpoints are made on word breaks, so they should be remain consistent
                    if (index != rulers.front.point.length) {
                        // TODO This should be relaxed in the future for nonbreaking text or user-inserted checkpoints
                        assert(false, format!"Checkpoint found at %s (%s...) in word(%s); word breaks are at %s and %s"(
                            rulers.front.point.length, value[rulers.front.point.length..$].take(10), 
                            word, startIndex, index));
                    }

                    // X position is different, override the ruler and continue measurements
                    if (abs(rulers.front.penPosition.x - ruler.penPosition.x) >= epsilon.x) {
                        rulers.front = ruler;
                        rulers.popFront();
                        continue;
                    }

                    // Only Y position is different, stop here and save the offset 
                    else if (abs(rulers.front.penPosition.y - ruler.penPosition.y) >= epsilon.y) {
                        yOffset = ruler.penPosition.y - rulers.front.penPosition.y;
                        rulers.front = ruler;
                        rulers.popFront();
                        break lines;
                    }

                    // No difference, stop
                    else break lines;

                }

            }

        }

        // The remaining lines have no changes, so we can just apply the same offset we did on the last line
        // TODO Should textSize be tracked by TextRuler? It could be faster.
        for (; !rulers.empty; rulers.popFront) {
            auto thisRuler = rulers.front;
            thisRuler.penPosition.y += yOffset;
            thisRuler.textSize.y += yOffset;
            thisRuler.textSize.x = max(thisRuler.textSize.x, ruler.textSize.x);
            rulers.front = thisRuler;
        }

        // Now that the cache is built, we can find out what the position of the last character is so we can get 
        // the bounding box
        ruler = requireRulerAt(value.length);
        _sizeDots = ruler.textSize;
        _updateRangeStart = 0;
        _updateRangeEnd = 0;

    }

    bool isMeasured() const {

        return _cache !is _cache.init
            && _updateRangeStart == _updateRangeEnd;

    }

    /// `rulerAt` gets measurement data for the given text position. This data can be used to map characters to their 
    /// screen position or find their size. 
    ///
    /// For this function to work, measurement data must be available; make sure `resize` was called beforehand. This
    /// will be checked at runtime.
    ///
    /// Returns: 
    ///     Text ruler with text measurement data from the start of the text to the given character, not including 
    ///     queried character. The ruler has an extra `point` field, indicating distance from the start of the text.
    /// Params:
    ///     index = Index of the requested character.
    ///     preferNextLine = If the index is between two characters on different visual lines (and neither is a line
    ///         break), decides which of them should be used.
    CachedTextRuler rulerAt(size_t index, bool preferNextLine = false)
    in (_cache !is _cache.init, "Text was not measured. Call `resize()` first.")
    do {

        // TODO Custom text breaking

        /// Returns the longest unbreakable substring of the given value.
        Rope unbreakableChars(Rope value) {

            // Split on lines
            auto lines = value.byLine;
            if (lines.empty) return Rope.init;

            // Split on words
            auto chunks = Typeface.defaultWordChunks(lines.front);
            if (chunks.empty) return Rope.init;

            // Return empty string if the result starts with whitespace
            if (chunks.front.byDchar.front.isWhite) return value.init;

            // Return first word only
            return chunks.front;

        }

        alias splitter = Typeface.defaultWordChunks;

        auto ruler = freshCacheQuery(index).front;
        bool started;

        assert(ruler.typeface !is null);

        // Found an exact match
        if (index == ruler.point.length) return ruler;

        // Check if the caret follows unbreakable characters
        // If the caret is surrounded by unbreakable characters, include them in the output to make sure the
        // word is wrapped correctly
        const unbreakablePrefix = unbreakableChars(
            value[0 .. index].wordBack(true)
        );
        const unbreakableSuffix = unbreakablePrefix.empty && !preferNextLine
            ? Rope.init
            : unbreakableChars(value[index .. $]);

        const start = ruler.point.length;
        const end   = index + unbreakableSuffix.length;

        // Measure characters between the checkpoint and the queried word
        foreach (line; value[start .. end].byLine) {

            if (started) {
                ruler.startLine();
                ruler.point.line++;
                ruler.point.column = 0;
            }
            else started = true;

            ruler.point.length += line.withSeparator.length;
            ruler.point.column += line.length;

            // Split on words, but don't do anything
            foreach (word, penPosition; Typeface.eachWord!splitter(ruler, line, _wrap)) { }

        }

        // If the position is mid-word, we have to remove the suffix
        // TODO textSize might be incorrect here
        ruler.penPosition.x -= ruler.typeface.measure(unbreakableSuffix[]).x;

        // The ruler cannot wrap in the middle of the word
        ruler.canWrap = false;

        return ruler;

    }

    /// Find a text index corresponding to a screen position
    ///
    /// Params:
    ///     needle = Position of the character, starting with the top-left corner of the text.
    ///         `rulerAtPosition` uses pixels (recommended), `rulerAtPositionDots` uses screen dots.
    /// Returns: 
    ///     Text ruler with text measurement data from the start of the text to the given character, not including 
    ///     queried character. The ruler has an extra `point` field, indicating distance from the start of the text.
    CachedTextRuler rulerAtPosition(Vector2 needle) {

        return rulerAtPositionDots(backend.scale * needle);

    }
    
    /// ditto
    CachedTextRuler rulerAtPositionDots(Vector2 needle) {

        // TODO RTL support

        alias splitter = Typeface.defaultWordChunks;

        // Find the closest relevant ruler in the cache
        auto ruler = queryPosition(&_cache, needle.y).front;

        const start = ruler.point.length;
        
        // Find the word; find a matching line
        foreach (line; value[start .. $].byLine) {

            const nextLine = ruler.point.length + line.withSeparator.length;

            scope (exit) {
                ruler.startLine();
                ruler.point = TextInterval(nextLine, ruler.point.line + 1, 0);
            }

            auto lastWord = ruler;

            // Split on words
            foreach (word, wordPosition; eachWord!splitter(ruler, line, _wrap)) {

                const wordInterval = TextInterval(word.length, 0, word.length);

                alias wordEnd = ruler;

                // Set wordStart and wordEnd rulers
                auto wordStart = ruler;
                wordStart.penPosition = wordPosition;
                wordEnd.point += wordInterval;
                scope (exit) lastWord = wordEnd;

                // If we're not on the target line, there's nothing specific to do to these words
                if (ruler.caret.end.y < needle.y) continue;

                // Passed the line without matching anything
                if (ruler.caret.start.y > needle.y && lastWord.caret.start.y <= needle.y) return lastWord;

                // Detect when the caret passes the selected word; 
                // Compare both pen position before the word (wordPosition) and after (ruler.penPosition)
                // If they're on the opposite side of the needle, we've got a match.
                const passed = (wordPosition.x <= needle.x && ruler.penPosition.x >= needle.x)
                    || (wordPosition.x >= needle.x && ruler.penPosition.x <= needle.x);

                // Search the word for the needle, if it's known it is inside
                if (passed) return indexAtDotsWord(wordStart, wordEnd.point, needle.x);
            
            }

            if (ruler.caret.end.y >= needle.y) return ruler;

        }

        // Output the end of the sentence
        // TODO RTL and right alignment
        ruler.canWrap = false;
        return ruler;

    }

    private CachedTextRuler requireRulerAt(size_t index) {

        auto ruler = rulerAt(index);
        _cache.insert(ruler.point, ruler);
        return ruler;

    }

    /// Find a text index corresponding to a screen position
    ///
    /// This function may return an index equal to text length if the position is at the end of text.
    ///
    /// Params:
    ///     needle = Position of the character, starting with the top-left corner of the text.
    ///         `indexAt` uses pixels (recommended), `indexAtDots` uses screen dots.
    /// Returns:
    ///     Index of a matching character, or the same index + 1 if the point is to its right.
    ///     If pressed out of bounds, returns the closest character of the line, or the last character in the text.
    size_t indexAt(Vector2 needle) {

        return indexAtDots(backend.scale * needle);

    }

    /// ditto
    size_t indexAtDots(Vector2 needle) {

        return rulerAtPositionDots(needle).point.length;

    }

    private CachedTextRuler indexAtDotsWord(CachedTextRuler wordStart, TextInterval wordEndPoint, float needle) {

        import std.utf : codeLength;

        // Now that the word of interest was found, it's time to search for the exact character
        auto ruler = wordStart;
        auto bestMatchDistance = float.infinity;
        auto bestMatch = ruler;

        const word = value[wordStart.point.length .. wordEndPoint.length];

        foreach (character; word.byDchar) {

            ruler.canWrap = false;

            const characterLength = character.codeLength!char;

            auto start = ruler;
            ruler.addWord(only(character));
            ruler.point.length += characterLength;
            ruler.point.column += characterLength;
            auto end = ruler;

            const middlePosition = start.penPosition.x + (end.penPosition.x - start.penPosition.x) / 2;
            const distance = abs(needle - middlePosition);

            // Match against either half of the text
            // TODO LTR support
            // TODO shortcircuit
            if (distance < bestMatchDistance) {
                bestMatchDistance = distance;
                if (needle <= middlePosition) {
                    bestMatch = start;
                }
                else {
                    bestMatch = end;
                }
            }

        }

        bestMatch.canWrap = false;
        return bestMatch;

    }

    /// Reset the texture, destroying it and replacing it with a blank.
    void clearTextures() {

        texture.format = Image.Format.palettedAlpha;
        texture.resize(_sizeDots, hasFastEdits);

    }

    /// Generate the textures, if not already generated.
    ///
    /// Params:
    ///     chunks = Indices of chunks that need to be regenerated.
    ///     position = Position of the text; If given, only on-screen chunks will be generated.
    void generate(Vector2 position) {

        generate(texture.visibleChunks(position, backend.windowSize));

    }

    /// ditto
    void generate(R)(R chunks) @trusted {

        // Empty, nothing to do
        if (chunks.empty) return;

        auto style = node.pickStyle;
        auto typeface = style.getTypeface;
        const dpi = backend.dpi;
        const scale = backend.hidpiScale;

        // Apply sizing settings
        style.setDPI(dpi);
        typeface.indentWidth = cast(int) (indentWidth * scale.x);

        // Ignore chunks which have already been generated
        auto newChunks = chunks
            .filter!(index => !texture.chunks[index].isValid);

        // No chunks to render, stop here
        if (newChunks.empty) return;

        auto startY = +float.infinity;
        auto endY   = -float.infinity;

        // Clear the chunks
        foreach (chunkIndex; newChunks.save) {

            texture.clearImage(chunkIndex);

            // Find the topmost and bottommost chunk
            auto rect = texture.chunkRectangle(chunkIndex);
            if (rect.y < startY) startY = rect.y;
            if (rect.end.y > endY) endY = rect.end.y;

        }

        auto ruler = rulerAtPositionDots(Vector2(0, startY));
        bool started;

        const start = ruler.point.length;

        // Copy the layer range, make it infinite
        auto styleMap = this.styleMap.save.chain(TextStyleSlice.init.repeat);

        // Run through the text
        foreach (line; value[start .. $].byLine) {

            auto index = start + line.index;

            if (started) {
                ruler.startLine();
            }
            else started = true;

            // Stop when reached the end of the drawable area
            if (ruler.caret.y > endY) break;

            // Split on words
            // TODO use the splitter provided when resizing
            foreach (word, penPosition; Typeface.eachWord(ruler, line, _wrap)) {

                const wordEnd = index + word.length;

                // Split the word based on the layer map
                // Draw each fragment separately
                while (index != wordEnd) {

                    const remaining = wordEnd - index;
                    auto wordFragment = word[$ - remaining .. $];
                    auto range = styleMap.front;

                    // Advance the layer map if the index is past the end of the current fragment
                    if (index >= range.end) {
                        styleMap.popFront;
                        continue;
                    }

                    ubyte styleIndex;

                    // This fragment matches a style from the style map,
                    // activate the style
                    if (index >= range.start) {

                        // Find the end of the range
                        const end = min(wordEnd, range.end) - index;
                        wordFragment = wordFragment[0 .. end];
                        styleIndex = range.styleIndex;

                    }

                    // There's a split later in this word, draw up to that fragment
                    else if (range.start < wordEnd) {

                        wordFragment = wordFragment[0 .. range.start - index];

                    }

                    const currentPenPosition = penPosition;

                    // Draw the fragment to selected chunks
                    foreach (chunkIndex; newChunks) {

                        const chunkRect = texture.chunkRectangle(chunkIndex);

                        // Ignore chunks this word is not in the bounds of
                        const startCaret = ruler.caret(currentPenPosition);
                        const endCaret = ruler.caret();
                        const relevant = 
                               chunkRect.contains(startCaret.start)
                            || chunkRect.contains(startCaret.end)
                            || chunkRect.contains(endCaret.start)
                            || chunkRect.contains(endCaret.end);
                            
                        if (!relevant) continue;

                        // Get pen position relative to this chunk
                        auto relativePenPosition = currentPenPosition - chunkRect.start;

                        // Note: relativePenPosition is passed by ref
                        auto image = texture.chunks[chunkIndex].image;
                        typeface.drawLine(image, relativePenPosition, wordFragment, styleIndex);

                        // Update the pen position; Result of this should be the same for each chunk
                        penPosition = relativePenPosition + chunkRect.start;

                    }

                    // Update the index
                    index += wordFragment.length;

                }

            }

        }

        // Load the updated chunks
        foreach (chunkIndex; newChunks) {

            texture.upload(backend, chunkIndex, dpi);

        }

    }

    /// Draw the text.
    void draw(const Style style, Vector2 position) {

        scope const Style[1] styles = [style];

        draw(styles, position);

    }

    /// ditto
    void draw(scope const Style[] styles, Vector2 position)
    in (styles.length >= 1, "At least one style must be passed to draw(Style[], Vector2)")
    do {

        import std.math;
        import fluid.utils;

        const rectangle = Rectangle(position.tupleof, size.tupleof);
        const screen = Rectangle(0, 0, node.io.windowSize.tupleof);

        // Ignore if offscreen
        if (!overlap(rectangle, screen)) return;

        // Regenerate visible textures
        generate(position);

        // Make space in the texture's palette
        if (texture.palette.length != styles.length)
            texture.palette.length = styles.length;

        // Fill it with text colors of each of the styles
        styles.map!"a.textColor".copy(texture.palette);

        // Draw the texture if present
        texture.drawAlign(backend, rectangle);

    }

    /// ditto
    deprecated("Use draw(Style, Vector2) instead. Hint: Use fluid.utils.start(Rectangle) to get the position vector.")
    void draw(const Style style, Rectangle rectangle) {

        // Should this "crop" the result?

        draw(style, Vector2(rectangle.x, rectangle.y));

    }

    string toString() const {

        import std.conv : to;

        return _value.to!string;

    }

}

struct TextStyleSlice {

    /// Start and end of this slice. Start is inclusive, end is exclusive. The range may exceed text boundaries.
    auto start = size_t.max;

    /// ditto
    auto end = size_t.max;

    invariant(start <= end);

    /// Index of the style to be assigned to the text covered by this slice.
    ubyte styleIndex;

    ptrdiff_t opCmp(const TextStyleSlice that) const {

        return cast(ptrdiff_t) this.start - cast(ptrdiff_t) that.start;

    }

    /// Apply some offset to the slice.
    TextStyleSlice offset(int offset) const {

        return TextStyleSlice(start + offset, end + offset, styleIndex);

    }

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();
    auto text = Text(root, "Hello, green world!");

    // Set colors for each part
    Style[4] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");
    styles[2].textColor = color("#55b9ff");
    styles[3].textColor = color("#0058f1");

    // Define regions
    text.styleMap = [
        TextStyleSlice(7, 12, 1),   // green
        TextStyleSlice(13, 14, 2),  // w
        TextStyleSlice(14, 15, 3),  // o
        TextStyleSlice(15, 16, 2),  // r
        TextStyleSlice(16, 17, 3),  // l
        TextStyleSlice(17, 18, 2),  // d
    ];

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize();
    text.draw(styles, Vector2(0, 0));

    // Make sure the texture was drawn with the correct color
    io.assertTexture(text.texture.chunks[0], Vector2(), color("#fff"));

    foreach (i; 0..4) {

        assert(text.texture.chunks[0].palette[i] == styles[i].textColor);
        assert(text.texture.palette[i] == styles[i].textColor);

    }

    // TODO Is there a way to reliably test if the result was drawn properly? Sampling specific pixels maybe?

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto styleMap = recurrence!"a[n-1] + 1"(0)
        .map!(a => TextStyleSlice(a, a+1, cast(ubyte) (a % 2)));

    auto text = mapText(root, "Hello, World!", styleMap);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(50, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto styleMap = [
        TextStyleSlice(2, 11, 1),
    ];

    auto text = mapText(root, "Hello, World!", styleMap);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(60, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    Style[2] styles;
    auto root = vspace();
    auto styleMap = [
        TextStyleSlice(0, 0, 1),
    ];
    auto text = mapText(root, "Hello, World!", styleMap);

    root.draw();
    text.resize();
    text.draw(styles, Vector2(0, 0));

}

version (unittest) {

    mixin template indexAtTest() {

        void test(size_t expected, Vector2 position) {

            const index = root.text.indexAt(position);

            if (index == expected) {
                io.drawPointer(position, color("#0a0"));
            }
            else {
                io.drawPointer(position);
                io.saveSVG("/tmp/fluid.svg");
                debug assert(false, format!"Expected %s, got %s"(expected, index));
            }

        }

    }

}

@("Text.indexAt works with multiple lines of text")
unittest {

    // This test depends on specific properties of the default typeface

    import fluid.label;
    import std.stdio;

    auto root = label(testTheme, "Hello, World!\nHi, Globe!\nWelcome, Fluid user!");
    auto io = new HeadlessBackend;
    root.io = io;
    root.draw();

    mixin indexAtTest;

    const lineHeight = root.style.getTypeface.lineHeight;

    // First line
    test( 0, Vector2(  0, 0));
    test( 1, Vector2( 10, 0));
    test( 3, Vector2( 30, lineHeight/2));
    test( 7, Vector2( 60, lineHeight/3));
    test( 8, Vector2( 70, lineHeight/3));
    test(12, Vector2(104, lineHeight/3));
    test(13, Vector2(108, lineHeight/3));
    test(13, Vector2(140, lineHeight/3));

    // Second line
    test(14, Vector2(4, lineHeight * 1.5));
    test(19, Vector2(40, lineHeight * 1.1));
    test(24, Vector2(400, lineHeight * 1.9));

    // Third line
    test(29, Vector2( 40, lineHeight * 2.1));
    test(32, Vector2( 80, lineHeight * 2.9));
    test(38, Vector2(120, lineHeight * 2.5));
    test(45, Vector2(180, lineHeight * 2.2));
    test(45, Vector2(220, lineHeight * 2.6));

    // Before it all
    test( 0, Vector2(  0, -20));
    test( 1, Vector2( 10, -40));
    test( 3, Vector2( 30, -5));
    test( 7, Vector2( 60, -60));
    test( 8, Vector2( 70, -80));
    test(12, Vector2(104, -90));
    test(13, Vector2(108, -25));
    test(13, Vector2(140, -12));

}

@("Text.indexAt works correctly with blank lines")
unittest {

    // This test depends on specific properties of the default typeface

    import fluid.label;
    import std.stdio;

    auto root = label(nullTheme, "\r\nHello,\n\nWorld!\n");
    auto io = new HeadlessBackend;
    root.io = io;
    root.draw();

    mixin indexAtTest;

    const lineHeight = root.style.getTypeface.lineHeight;

    // First line — all point to zero
    test(0, Vector2(-40, lineHeight*0.5));
    test(0, Vector2(  0, 0));
    test(0, Vector2( 60, lineHeight*0.3));
    test(0, Vector2(140, lineHeight*0.8));

    // Second line
    test(2, Vector2(0,   lineHeight*1.1));
    test(8, Vector2(50,  lineHeight*1.8));
    test(8, Vector2(200, lineHeight*1.1));

    // Third line — empty
    test(9, Vector2(-100, lineHeight*2.4));
    test(9, Vector2(0,    lineHeight*2.3));
    test(9, Vector2(100,  lineHeight*2.9));

    // Fourth line
    // TODO test(10, Vector2(-100, lineHeight*3.4));
    test(10, Vector2(0,    lineHeight*3.3));
    test(16, Vector2(100,  lineHeight*3.9));

    // Fifth line — empty
    test(17, Vector2(-100, lineHeight*4.9));
    test(17, Vector2(0,    lineHeight*4.5));
    test(17, Vector2(100,  lineHeight*4.1));

    // Beyond — empty
    test(17, Vector2(-100, lineHeight*5.9));
    test(17, Vector2(0,    lineHeight*5.5));
    test(17, Vector2(100,  lineHeight*5.1));

}

@("Text.measure correctly updates checkpoints in the same line")
unittest {

    import fluid.label;

    const repeatedText = "A checkpoint will be placed after every occurence of this sentence. ";
    const occurences = 4;

    auto root = label(
        repeatedText.repeat(occurences).join,
    );
    root.draw();

    foreach (i; 0..occurences) {
        root.text.requireRulerAt((i + 1) * repeatedText.length);
    }

    const endOfText = root.text.rulerAt(root.text.length);

    // placed -> replaced
    root.text.replace(21, 27, "replaced");
    root.draw();

    const newEnd = root.text.rulerAt(root.text.length);

    assert(newEnd.penPosition.y >= endOfText.penPosition.y);
    
}

@("Text.measure correctly updates checkpoints on different lines")
unittest {

    import fluid.label;

    const repeatedText = "A checkpoint will be placed after every occurence of this sentence.\n";
    const occurences = 20;

    auto root = label(
        repeatedText.repeat(occurences).join,
    );
    root.draw();

    // Add checkpoints between every word to make sure the behavior is consistent
    foreach (i; 0..occurences) {
        auto index = i * repeatedText.length;
        foreach (word; breakWords(repeatedText.chomp)) {
            index += word.length;
            root.text.requireRulerAt(index);
        }
    }

    const endOfText = root.text.rulerAt(root.text.length);

    root.text.replace(21, 27, "\n");
    root.draw();

    const newEnd = root.text.rulerAt(root.text.length);

    assert(newEnd.penPosition.y >= endOfText.penPosition.y);
    
}

@("Overflowing text does not break layout")
unittest {

    import fluid.label;

    const longText = "helloworld".repeat(100).join;

    auto root = label(.testTheme, longText);
    root.draw();

    const startRuler = root.text.rulerAt(0);
    const endRuler = root.text.rulerAt(longText.length);

    assert(startRuler.penPosition.y == endRuler.penPosition.y);

}

@("Rulers cannot appear in the middle of a long word")
unittest {

    import fluid.label;

    auto root = label(.testTheme, "");

    foreach (i; 0..50) {

        root.text ~= "helloworld";
        root.draw();

    }

    const startRuler = root.text.rulerAt(0);
    const endRuler = root.text.rulerAt(root.text.length);

    assert(startRuler.penPosition.y == endRuler.penPosition.y);
    assert(query(&root.text._cache, 0).walkLength == 2);

}

@("Text updates its size when editing")
unittest {

    import fluid.label;

    auto root = label(
        `return vframe(\n` ~
        `    label("First line"),\n` ~
        `    label("Second line"),\n` ~
        `    label("Third line"),\n` ~
        `);`
    );

    root.draw();

    const index = root.text.byChar.indexOf(`\n    label("Third line")`);
    const firstTextSize = root.text.size;

    root.text.replace(index, index, "asdfg");
    root.draw();

    const secondTextSize = root.text.size;

    assert(firstTextSize.x < secondTextSize.x);
    assert(firstTextSize.y == secondTextSize.y);

}

@("Text rendering is consistent for large text")
unittest {

    import std.file;
    import fluid.label;

    const source = Rope.merge(Rope("the quick brown fox jumps over the lazy dog. ").repeat(100).array);
    const fontSize = 10;
    
    auto theme = .testTheme.derive(
        rule!Node(
            Rule.fontSize = fontSize,
        ),
    );
    auto io = new HeadlessBackend(Vector2(200, 1000));
    auto root = label(theme, source);
    auto text = root.text;

    const space = io.windowSize;

    root.io = io;
    theme.apply(root, root.style);
    text.hasFastEdits = true;
    text.resize(space);

    assert(text.node.pickStyle.fontSize == fontSize);

    Image[2] backImages;
    Image[2] frontImages;
    
    // Draw the first two textures separately
    foreach_reverse (i, ref chunk; text.texture.chunks[0..2]) {

        const position = text.texture.chunkPosition(i);

        text.generate(only(i));        
        text.texture.upload(io, i, io.dpi);
        chunk.texture.draw(position);

        // Move the image to the list
        backImages[i] = chunk.image;
        chunk = chunk.init;

    }

    io.nextFrame;
    text.resize(space);
    text.clearTextures();

    // Now render both at once
    text.generate(only(0, 1));        

    foreach (i, ref chunk; text.texture.chunks[0..2]) {

        const position = text.texture.chunkPosition(i);

        text.texture.upload(io, i, io.dpi);
        chunk.texture.draw(position);

        // Move the image to the list
        frontImages[i] = chunk.image;
        chunk = chunk.init;

    }

    assert(frontImages[] == backImages[], "Two separately rendered pieces of text should look identical");

}
